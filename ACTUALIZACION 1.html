<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Página de Video Interactiva Potenciada</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.6.0/uicons-regular-rounded/css/uicons-regular-rounded.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.6.0/uicons-regular-straight/css/uicons-regular-straight.css'>

    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.6.0/uicons-solid-straight/css/uicons-solid-straight.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.6.0/uicons-thin-straight/css/uicons-thin-straight.css'>
    <link rel='stylesheet' href='https://cdn-uicons.flaticon.com/2.6.0/uicons-solid-rounded/css/uicons-solid-rounded.css'>
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/quill-blot-formatter/dist/quill-blot-formatter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html-docx-js/dist/html-docx.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>    
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2? family=Roboto:wght@300;400;700&family=Open+Sans:wght@300;400;700&family=Lato:wght@300;400;700&family=Montserrat:wght@300;400;700&family=Oswald:wght@300;400;700&family=Raleway:wght@300;400;700&family=Merriweather:wght@300;400;700&family=Nunito:wght@300;400;700&family=Playfair+Display:wght@400;700&family=Poppins:wght@300;400;500;600;700&family=Ubuntu:wght@300;400;700&family=Dancing+Script&family=Pacifico&display=swap" rel="stylesheet">
  
    <style>
        /* --- ESTILOS GLOBALES --- */
        :root {
            --color-bg: #f0f2f7;
            --color-surface: #ffffff;
            --color-primary: #8a4dff;
            --color-primary-light: #e7dffd;
            --color-text-primary: #2d3142;
            --color-text-secondary: #8a8f9d;
            --color-success: #4caf50;
            --color-success-light: #e8f5e9;
            --color-warning: #ff9800;
            --color-error: #f44336;
            --color-error-light: #ffebee;
            --color-low-medium: #90a4ae;
            --color-border: #e0e2e8;
            --shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            --border-radius: 16px;
            
            --sidebar-width-collapsed: 80px;
            --sidebar-width-expanded: 300px;
            --header-height: 65px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Poppins', sans-serif; }
        #outer-wrapper, #main-wrapper { width: 100%; }
        html { height: 100%; }
        body { background-color: var(--color-bg); color: var(--color-text-primary); }

        /* --- SCROLLBARS MODERNAS --- */
/* --- SCROLLBARS INTELIGENTES (AUTO-HIDE) --- */
        /* Configuración para Firefox */
        * { 
            scrollbar-width: thin; 
            scrollbar-color: transparent transparent; /* Oculto por defecto */
            transition: scrollbar-color 0.3s ease;
        }
        /* Mostrar en Firefox al pasar el mouse sobre el elemento */
        *:hover { 
            scrollbar-color: var(--color-primary) transparent; 
        }

        /* Configuración para Chrome, Edge, Safari */
        *::-webkit-scrollbar { width: 8px; height: 8px; }
        *::-webkit-scrollbar-track { background: transparent; }
        
        /* El "pulgar" (la barra que se mueve) transparente por defecto */
        *::-webkit-scrollbar-thumb { 
            background-color: transparent; 
            border-radius: 10px; 
            transition: background-color 0.3s ease;
        }

        /* Mostrar el pulgar solo cuando el mouse está encima del contenedor */
        *:hover::-webkit-scrollbar-thumb { 
            background-color: var(--color-primary); 
            border: 2px solid transparent; 
            background-clip: content-box; 
        }

        /* --- LAYOUT PRINCIPAL --- */
        #app-layout {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-content {
            height: 100vh;
            overflow-y: auto;
            flex-grow: 1;
            margin-left: var(--sidebar-width-collapsed); /* Por defecto deja espacio para la barra colapsada */
            width: calc(100% - var(--sidebar-width-collapsed));
            transition: margin-left 0.25s cubic-bezier(0.2, 0, 0, 1), width 0.25s cubic-bezier(0.2, 0, 0, 1);
           /* transition: margin-left 0.3s ease, width 0.3s ease;*/
            position: relative;
        }

        /* --- OVERLAY DE FONDO --- */
        #sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgb(71 78 91 / 32%); 
            backdrop-filter: none;
         /*   background: linear-gradient(to right, rgba(0,0,0,0.4), rgba(0,0,0,0.1));
            backdrop-filter: blur(2px);*/
            z-index: 95;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }


        
        /* --- BARRA LATERAL (SIDEBAR) --- */
        .app-sidebar {
            width: var(--sidebar-width-expanded);
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            background-color: var(--color-surface);
            border-right: 1px solid var(--color-border);
            display: flex;
            flex-direction: column;
            transition: width 0.25s cubic-bezier(0.2, 0, 0, 1), transform 0.25s cubic-bezier(0.2, 0, 0, 1);
            will-change: width, transform;
          /*  transition: width 0.3s ease, transform 0.3s ease;*/
            overflow: hidden;
            box-shadow: 5px 0 30px rgba(0,0,0,0.1); 
        }
        
        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            height: var(--header-height);
            flex-shrink: 0;
            border-bottom: 1px solid var(--color-border);
        }
        .sidebar-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            overflow: hidden;
        }
        .sidebar-logo img { width: 35px; height: 35px; flex-shrink: 0; }
        .sidebar-logo .logo-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--color-text-primary);
            white-space: nowrap;
            transition: opacity 0.2s ease;
        }
        
        #sidebar-close-btn { display: none; }

        /* FOOTER SIDEBAR */
        .sidebar-footer {
            padding: 1rem;
            margin-top: auto;
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        #sidebar-toggle-btn {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            width: auto;
            padding: 0 0.75rem;
            height: 35px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        #sidebar-toggle-btn i { font-size: 1.1rem; transition: transform 0.3s ease; }
        #sidebar-toggle-btn .toggle-text { font-weight: 500; white-space: nowrap; }
        #sidebar-toggle-btn:hover { background-color: var(--color-bg); }

        /* FILTROS */
        .sidebar-filters {
            padding: 1rem;
            border-bottom: 1px solid var(--color-border);
            flex-shrink: 0;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            transition: all 0.3s ease;
        }
        .search-bar-container {
            position: relative;
            flex-grow: 1;
            transition: opacity 0.2s ease;
        }
        .search-bar-container i {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--color-text-secondary);
            font-size: 0.9rem;
        }
        #search-subtopics {
            width: 100%;
            padding: 0.7rem 0.7rem 0.7rem 2.25rem;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            font-size: 0.9rem;
            background-color: var(--color-bg);
        }
        #search-subtopics:focus {
            background-color: var(--color-surface);
            border-color: var(--color-primary);
            outline: none;
        }
        #filter-btn {
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            color: var(--color-text-secondary);
            width: 35px;
            height: 35px;
            border-radius: 8px;
            cursor: pointer;
            display: grid;
            place-items: center;
            font-size: 0.9rem;
            flex-shrink: 0;
        }
        #filter-btn:hover, #filter-btn.active {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
        }

        /* LISTA TEMAS */
        .sidebar-topic-list {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 1rem 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .topic-group .topic-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .topic-group .topic-header:hover { background-color: var(--color-bg); }
        
        .topic-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--color-text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .topic-toggle-icon {
            color: var(--color-text-secondary);
            transition: transform 0.3s ease;
            font-size: 0.8rem;
        }
        .topic-group.open .topic-toggle-icon { transform: rotate(180deg); }

        .subtopic-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.25s cubic-bezier(0.4, 0, 0.2, 1), padding 0.2s ease;
          /*  transition: max-height 0.3s ease-out, padding 0.3s ease;*/
            padding-left: 0.75rem;
        }
        .topic-group.open .subtopic-list { max-height: 100%;/*max-height: 800px; max-height: 2000px;*/ }
        
        .subtopic-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.8rem 0.5rem;
            margin-bottom: 5px;
            border-radius: 8px;
            text-decoration: none;
            transition: background-color 0.2s ease;
        }
        .subtopic-item:hover { background-color: var(--color-primary-light); }
        .subtopic-item.active { background-color: var(--color-primary-light); }
        .subtopic-item.active .subtopic-title { color: var(--color-primary); font-weight: 600; }
        
        .subtopic-check-icon {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            flex-shrink: 0;
            transition: color 0.3s ease;
        }
        
        /* Colores por prioridad (Sin Completar) */
        .subtopic-item:not(.completed) .subtopic-check-icon.priority-high { color: var(--color-success); }
        .subtopic-item:not(.completed) .subtopic-check-icon.priority-medium { color: var(--color-warning); }
        .subtopic-item:not(.completed) .subtopic-check-icon.priority-low { color: var(--color-error); }
        .subtopic-item:not(.completed) .subtopic-check-icon.priority-low-medium { color: var(--color-low-medium); }

        /* --- CORRECCION: Colores Completados (Mantener color de prioridad pero Sólido) --- */
        .subtopic-item.completed .subtopic-check-icon.priority-high { color: var(--color-success) !important; }
        .subtopic-item.completed .subtopic-check-icon.priority-medium { color: var(--color-warning) !important; }
        .subtopic-item.completed .subtopic-check-icon.priority-low { color: var(--color-error) !important; }
        .subtopic-item.completed .subtopic-check-icon.priority-low-medium { color: var(--color-low-medium) !important; }

        .subtopic-title {
            font-size: 0.85rem;
            color: var(--color-text-secondary);
            font-weight: 500;
            line-height: 1.4;
            white-space: normal; 
        }

        /* === ESTILOS BASE PARA SIDEBAR COLAPSADO === */
        /* Esta clase se aplica por defecto en el HTML para evitar parpadeos */
        .app-sidebar.collapsed {
            width: var(--sidebar-width-collapsed);
            box-shadow: var(--shadow);
          border-radius: 0px 8px 8px 0px;
        }
        
        /* Ocultar elementos cuando está colapsado */
        .app-sidebar.collapsed .logo-text, 
        .app-sidebar.collapsed .search-bar-container,
        .app-sidebar.collapsed .topic-header,
        .app-sidebar.collapsed .subtopic-title,
        .app-sidebar.collapsed .toggle-text,
        .app-sidebar.collapsed .topic-toggle-icon {
            display: none !important;
        }

        /* Centrar elementos en colapsado */
        .app-sidebar.collapsed .sidebar-header { justify-content: center; padding: 0; }
        .app-sidebar.collapsed .sidebar-logo { justify-content: center; width: 100%; }
        
        .app-sidebar.collapsed .sidebar-footer {
            justify-content: center;
            padding: 1rem 0;
            border-top: none;
        }
        
        /* Toggle btn en estado colapsado (para 1100-1400px) */
        .app-sidebar.collapsed #sidebar-toggle-btn {
            width: 35px;
            padding: 0;
            display: grid;
            place-items: center;
        }
        .app-sidebar.collapsed #sidebar-toggle-btn i { transform: rotate(180deg); }
        
        .app-sidebar.collapsed .sidebar-filters { justify-content: center; padding: 1rem; }
        
        /* Estructura de lista en modo colapsado */
        .app-sidebar.collapsed .subtopic-list {
            max-height: none !important;
            padding-left: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding-top: 10px;
        }
        .app-sidebar.collapsed .subtopic-item {
            justify-content: center;
            padding: 0.8rem 0.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        .app-sidebar.collapsed .topic-group { margin-bottom: 0; width: 100%; }


/* --- ESTILOS MEJORADOS PARA EL POPUP DE NOTAS --- */
.modal-upload-area {
padding: 1rem 1.5rem;
    background-color: #f8f9fa;
    border-bottom: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
}

.upload-controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
}
      
   

      
      .badge-new, .badge-exist, .badge-duplicate {
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.7rem;
    margin-left: 6px; /* Separación entre etiquetas */
    font-weight: 600;
    letter-spacing: 0.3px;
    vertical-align: middle;
}

.badge-duplicate { 
    background: #fff5f5; 
    color: #c53030; 
    border: 1px solid #fed7d7; 
}

/* Edición dentro del modal */
.import-note-item {
    transition: all 0.2s ease;
}

.import-note-item.is-editing {
    background-color: #fff;
    border: 1px solid var(--color-primary);
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    padding: 0.8rem 1rem; /* Padding al editar */
    z-index: 2;
    position: relative;
}

.import-view-mode {
    display: flex;
    flex-direction: column;
    width: 100%;
    padding: 0.8rem 1rem;
    gap: 0.8rem; /* Espacio entre la cabecera y el contenido */
    background: white;
    /* Opcional: borde suave para diferenciar cada nota visualmente */
    border-radius: 8px; 
}
      
      
/* Nueva clase para la fila superior (Checkbox a la izq, Botones a la der) */
.import-card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    border-bottom: 1px dashed #eee; /* Separador sutil */
    padding-bottom: 5px;
}

/* Ajuste del contenedor de botones */
.import-actions-cell {
    display: flex;
    gap: 8px; /* Un poco más de espacio entre botones */
}      
      
      
/* El contenido ocupa todo el ancho naturalmente al estar en flex-column */
.import-note-content {
    width: 100%;
}

/* Ajuste visual para el checkbox para que sea más fácil de tocar */
.import-check {
    width: 18px;
    height: 18px;
    cursor: pointer;
    accent-color: var(--color-primary);
}      
      
      
      
      
      
      
      
      


.import-btn-icon {
    width: 30px;
    height: 30px;
    border-radius: 6px;
    border: 1px solid var(--color-border);
    background: #fff;
    color: var(--color-text-secondary);
    cursor: pointer;
    display: grid;
    place-items: center;
    font-size: 0.9rem;
    transition: all 0.2s;
}
.import-btn-icon:hover { border-color: var(--color-primary); color: var(--color-primary); }
.import-btn-icon.delete:hover { border-color: var(--color-error); color: var(--color-error); background: #fff5f5; }


/* Formulario de edición */
.import-edit-form { display: flex; flex-direction: column; gap: 0.8rem; }

.import-edit-row { display: grid; grid-template-columns: 100px 1fr; gap: 0.8rem; }

.import-edit-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    padding-top: 0.5rem;
    border-top: 1px solid #f0f0f0;
}

.video-selector { width: 100%; padding: 0.6rem; border: 1px solid var(--color-border); border-radius: 6px; background: #fff; font-size: 0.85rem;} 

   
      
 /* --- ESTILOS DE EDICIÓN (RESTAURADOS Y UNIFICADOS) --- */
.note-item {
    transition: all 0.2s ease;
}
/* Por defecto, mostrar display y ocultar edit */
.note-content-display, .note-item-actions-display { display: block; }
.note-content-edit, .note-item-actions-edit { display: none; }

/* Cuando tiene la clase .is-editing, invertimos */
.note-item.is-editing .note-content-display, 
.note-item.is-editing .note-item-actions-display { display: none !important; }

.note-item.is-editing .note-content-edit { display: flex; flex-direction: column; gap: 0.5rem; width: 100%; }
.note-item.is-editing .note-item-actions-edit { display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 0.5rem; }

/* Grid para inputs en modo edición */
.note-edit-grid { display: grid; grid-template-columns: 80px 1fr; gap: 0.5rem; width: 100%; }

/* --- CORRECCIÓN QUICK VIEW (IGUALAR AL MAIN) --- */
.quick-view-notes .notes-container {
    height: 100%;
    display: flex;
    flex-direction: column;
}
.quick-notes-list {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.8rem;
    background-color: var(--color-bg); /* Mismo fondo que acordeón */
}
/* Footer Quick View idéntico al main */
.quick-notes-footer {
    flex-shrink: 0;
    padding: 1rem;
    background: var(--color-surface);
    border-top: 1px solid var(--color-border);
    display: flex;
    flex-direction: column;
    gap: 1rem;
}     
      
 
      
      
      
      
      
/* --- CORRECCIONES CRÍTICAS CSS --- */

/* --- PASO 1: CSS CORREGIDO PARA MENÚS FLOTANTES --- */
.ql-picker-options {
    max-height: 150px !important;
    overflow-y: auto !important;
    position: fixed !important; /* Clave para el efecto Sticky global */
    z-index: 20 !important;
    background-color: white !important;
    border: 1px solid #ccc !important;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2) !important;
    border-radius: 8px !important;
    padding: 8px !important;
    min-width: 160px !important;
    display: none; /* JS lo activa */
}
      
/* Ocultar scrollbar en los menús pero permitir scroll */
.ql-picker-options::-webkit-scrollbar {
    width: 6px;
}
.ql-picker-options::-webkit-scrollbar-thumb {
    background-color: rgba(0,0,0,0.2);
    border-radius: 4px;
}

/* Estilo para los inputs dentro de los menús (Size y Font) */
.picker-input-custom {
    width: 90%;
    margin: 5px auto 10px auto;
    display: block;
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
    text-align: center;
}      

/* Estilo items de favoritos */
.picker-fav-item {
    cursor: pointer;
    padding: 4px 8px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.picker-fav-item:hover {
    background-color: #f0f2f7;
    color: var(--color-primary);
}      
      
      
/* Corrección de alineación de items dentro del menú */
.ql-picker-item {
    padding: 2px 5px !important;
    cursor: pointer;
}
.ql-picker-item:hover {
    background-color: #f0f2f7;
    color: var(--color-primary);
}
      
.ql-snow .ql-picker.ql-font .ql-picker-item::before,
.ql-snow .ql-picker.ql-font .ql-picker-label::before {
    content: attr(data-value) !important; /* Usa el valor como nombre */
    text-transform: capitalize;
}

.ql-snow .ql-picker.ql-font .ql-picker-item[data-value=""]::before,
.ql-snow .ql-picker.ql-font .ql-picker-label[data-value=""]::before {
    content: "Sans Serif" !important;
}      
      
/* --- CORRECCIÓN DE FUENTES QUILL --- */
/* Estas clases conectan la selección del menú con la fuente real */
.ql-font-roboto { font-family: 'Roboto', sans-serif !important; }
.ql-font-open-sans { font-family: 'Open+Sans', sans-serif !important; }
.ql-font-lato { font-family: 'Lato', sans-serif !important; }
.ql-font-montserrat { font-family: 'Montserrat', sans-serif !important; }
.ql-font-oswald { font-family: 'Oswald', sans-serif !important; }
.ql-font-raleway { font-family: 'Raleway', sans-serif !important; }
.ql-font-merriweather { font-family: 'Merriweather', serif !important; }
.ql-font-nunito { font-family: 'Nunito', sans-serif !important; }
.ql-font-playfair { font-family: 'Playfair Display', serif !important; }
.ql-font-poppins { font-family: 'Poppins', sans-serif !important; }
.ql-font-ubuntu { font-family: 'Ubuntu', sans-serif !important; }
.ql-font-dancing-script { font-family: 'Dancing Script', cursive !important; }
.ql-font-pacifico { font-family: 'Pacifico', cursive !important; }
.ql-font-arial { font-family: 'Arial', sans-serif !important; }

/* Asegurar que el texto dentro del editor también respete esto */
.ql-editor .ql-font-roboto { font-family: 'Roboto', sans-serif !important; }
/* ... (Quill lo aplica automáticamente, pero las reglas de arriba son las vitales) */
      
      
.ql-picker.ql-font .ql-picker-item {
        font-size: 16px;
        padding: 5px 10px !important;
        border-bottom: 1px solid #f0f0f0;
    }      

      
/* Controles inyectados (Buscador y Favoritos) */
    .picker-search-input {
        width: 90%;
        margin: 5px auto;
        display: block;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 13px;
    }
    .picker-favorites-section {
        border-bottom: 2px solid var(--color-primary);
        padding-bottom: 5px;
        margin-bottom: 5px;
        background: #fdfdfd;
    }
    .picker-fav-label {
        font-size: 10px;
        color: #888;
        padding: 2px 10px;
        text-transform: uppercase;
    }
    .picker-item-actions {
        float: right;
        color: #ddd;
        cursor: pointer;
    }
    .picker-item-actions:hover, .is-favorite .picker-item-actions {
        color: gold;
    }      
/* === MEJORA 2: COLORES HEXADECIMALES === */
    .hex-color-input-container {
        padding: 8px;
        border-top: 1px solid #eee;
        display: flex;
        gap: 5px;
        align-items: center;
        background: #f9f9f9;
    }
    .hex-input {
        width: 70px;
        border: 1px solid #ccc;
        padding: 3px;
        font-size: 12px;
    }
    .hex-apply-btn {
        background: var(--color-primary);
        color: white;
        border: none;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
    }      
      
/* === MEJORA 3: SIZE INPUT === */
    .size-input-mode {
        width: 50px !important;
        border: 1px solid var(--color-primary);
        padding: 2px;
        text-align: center;
        border-radius: 4px;
    }

    /* === MEJORA 4: POSICIONAMIENTO FIXED STICKY === */
    /* Sobrescribimos y forzamos estilos para asegurar que se mueva */
    .ql-picker-options {
        position: fixed !important;
        /* Top y Left se calcularán por JS dinámicamente */
        max-height: 150px !important;
        overflow-y: auto !important;
    }      
      
      
      
      
/* 3. Visualización de TAMAÑOS (Números) */
.ql-snow .ql-picker.ql-size .ql-picker-item::before,
.ql-snow .ql-picker.ql-size .ql-picker-label::before {
    content: attr(data-value) !important;
}
/* Por defecto si es normal */
.ql-snow .ql-picker.ql-size .ql-picker-item[data-value=""]::before,
.ql-snow .ql-picker.ql-size .ql-picker-label[data-value=""]::before {
    content: "16px" !important; /* Valor por defecto */
}
      
.ql-snow .ql-picker-options {
    background-color: #fff;
    display: none;
    min-width: 0PX;
    padding: 4px 8px;
    position: absolute;
    white-space: nowrap;
}      
/* --- MEJORAS DEL EDITOR QUILL Y TOOLBAR --- */

/* 1. Wrapper para las flechas y la toolbar */
.quill-toolbar-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    background-color: #f8f9fa;
    border: 1px solid var(--color-border);
    border-bottom: none;
    border-radius: 8px 8px 0 0;
    z-index: 20; /* Asegurar que la barra esté sobre el editor */
}      
      
      
      
/* 2. Toolbar Horizontal (Flex y Scroll) */
.ql-toolbar.ql-snow {
    border: none !important;
    display: flex !important;
    align-items: center;
    gap: 5px;
    overflow-x: auto;
    flex-wrap: nowrap !important;
    padding: 8px 5px !important;
    width: 100%;
    scrollbar-width: none; /* Ocultar scroll */
}
.ql-toolbar.ql-snow.grabbing {
    cursor: grabbing;
}
.ql-toolbar.ql-snow::-webkit-scrollbar { display: none; }    
      
/* 3. Forzar que los grupos de botones (.ql-formats) estén horizontales */
.ql-toolbar.ql-snow .ql-formats {
    display: flex !important;
    flex-shrink: 0; /* Evitar que se aplasten */
    margin-right: 12px !important;
    padding-right: 12px;
    border-right: 1px solid #e0e0e0; /* Separador sutil */
}
.ql-toolbar.ql-snow .ql-formats:last-child {
    border-right: none;
}

/* 4. Flechas de navegación del Toolbar */
.toolbar-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    background: #fff;
    border: 1px solid var(--color-border);
    border-radius: 50%;
    display: none; /* JS las activa */
    place-items: center;
    cursor: pointer;
    z-index: 10;
    color: var(--color-text-secondary);
    font-size: 0.8rem;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.toolbar-arrow:hover { background-color: var(--color-primary-light); color: var(--color-primary); }
.toolbar-arrow-left { left: 4px; }
.toolbar-arrow-right { right: 4px; }

/* 5. Editor Resizable (Icono en la esquina) */
#editor-container, .import-quill-editor-container {
    resize: vertical; /* Permite estirar hacia abajo */
    overflow-y: auto !important; /* Necesario para que el resize funcione */
    min-height: 100px;
    max-height: 500px;
}      

      
#editor-container, 
.import-quill-editor-container, 
.editing-quill-container {
    background: #fff;
    border: 1px solid var(--color-border);
    border-top: none; /* Se une con la toolbar */
    border-radius: 0 0 8px 8px;
    min-height: 100px; /* Altura mínima cómoda */
    font-family: 'Poppins', sans-serif;
    font-size: 16px; /* Tamaño base legible */
}      
      
      
      
      
/* 6. Ajuste de lectura (Cuando NO se edita) */
.note-text-display.ql-editor {
    height: auto !important; /* Se ajusta al contenido */
    overflow-y: visible !important; /* Muestra todo sin scroll interno */
    min-height: auto !important;
    padding: 0 !important; /* Quitar padding extra de Quill en modo lectura */
  white-space: normal;
}
/* Evitar que las imágenes se salgan en modo lectura */
.note-text-display img {
    max-width: 100%;
    height: auto;
}
      
      
.ql-editor {
    height: auto !important; 
}      
      
      
/* --- FIX IMAGENES QUILL: EVITAR SCROLL INTERNO --- */
/* Esto fuerza a la imagen a ajustarse al ancho del contenedor de edición.
   Al no haber desbordamiento horizontal, el cuadro de redimensión no se descuadra. */
/* --- FIX IMAGENES QUILL: EVITAR SCROLL INTERNO Y AGARRE FANTASMA --- */
.ql-editor img {
    max-width: 100%;
    height: auto; 
    display: block; 
    -webkit-user-drag: none; /* Evita que el navegador intente arrastrar la imagen */
    user-drag: none;
}

/* Asegurar que el contenedor de edición maneje el scroll suavemente */
.editing-quill-container .ql-editor {
    overflow-x: hidden; /* Evita scroll horizontal forzado */
    width: 100%;
}

/* Fix visual para el overlay de resize cuando está activo */
/* Asegura que no sea tapado por otros elementos */
#editor-container, .editing-quill-container {
    position: relative; 
    z-index: 1; 
}      
      
      
      
      
      
      
      
      
      
      
      
      
      

/* --- ARREGLOS DEL MODAL DE IMPORTACIÓN --- */

/* Contenedor del item importado */
.import-note-item {
    width: 100%;
    box-sizing: border-box; /* Asegura que el padding no rompa el ancho */
    overflow: hidden; /* Corta lo que salga */
}

/* Contenido del texto importado */
.import-note-content p {
    word-wrap: break-word;      /* Romper palabras largas */
    overflow-wrap: break-word;  /* Estándar moderno */
    white-space: pre-wrap;      /* Respetar saltos de línea pero ajustar ancho */
    max-width: 100%;
}

/* Editor dentro del modal */
.import-quill-container {
    background: #fff;
    border-radius: 8px;
    margin-bottom: 10px;
}
/* Toolbar específico del modal (para que herede los estilos de arriba) */
.import-quill-container .ql-toolbar {
    border-radius: 8px 8px 0 0;
    background: #f8f9fa;
}
.import-quill-editor-container {
    border-top: none;
    border-radius: 0 0 8px 8px;
    background: #fff;
    min-height: 100px;
}      
      


/* Permitir que el acordeón desborde visualmente cuando se edita */
.note-accordion-content.allow-overflow,
.note-accordion-item.allow-overflow {
    overflow: visible !important;
    z-index: 10; /* Elevar capa */
    position: relative;
}

/* 2. Ajuste del Editor en Línea (Igual al Principal) */
.editing-quill-wrapper {
    position: relative;
    border: 1px solid var(--color-border);
    border-radius: 12px;
    background: #fff;
    margin-bottom: 10px;
}

/* Quitamos bordes internos para que se vea limpio */
.editing-quill-wrapper .ql-toolbar {
    border: none !important;
    border-bottom: 1px solid #eee !important;
    background-color: #f8f9fa;
    border-radius: 8px 8px 0 0;
}
.editing-quill-wrapper .ql-container {
    border: none !important;
    border-radius: 0 0 8px 8px;
    min-height: 100px; /* Altura cómoda */
}

/* Flechas del carrusel en el editor en línea */
.editing-quill-wrapper .toolbar-arrow {
    background: #fff; /* Asegurar fondo blanco */
    border: 1px solid #ccc;
    z-index: 20;
}

/* 3. Ajuste de Texto Mostrado (Eliminar espacios extra) */
.note-text-display.ql-editor {
    padding: 0 !important; /* Quitar padding de Quill */
    height: auto !important;
    min-height: 0 !important;
    overflow-y: visible !important;
    margin-bottom: 0 !important;
}
.note-text-display.ql-editor p {
    margin-bottom: 0.5em; /* Espaciado normal de párrafos */
    line-height: 1.5;
}
/* Eliminar margen del último párrafo para que pegue al borde */
.note-text-display.ql-editor p:last-child {
    margin-bottom: 0;
}      
      
      
      
      
      
      
      
      


/* --- 3. SOLUCIÓN Z-INDEX (Menús desplegables por encima de todo) --- */
/* Asegura que los selectores de color/fuente no se corten */
.ql-container {
    font-family: 'Poppins', sans-serif; /* Fuente por defecto */
    font-size: 16px;
}

      
.ql-picker.ql-expanded .ql-picker-options {
    display: block !important;
}      
      
      
.ql-snow .ql-tooltip {
    background-color: #fff;
    border: 1px solid #ccc;
    box-shadow: 0px 0px 5px #ddd;
    color: #444;
    padding: 5px 12px;
    white-space: break-spaces;
    left: 0px !important;
    border-radius: 10px;
    max-width: 70%;  
    max-height: 120px;
    overflow-y: auto;
    font-size: 13px;
    font-weight: 600;
}      
      
      
      
.ql-snow .ql-picker.ql-expanded .ql-picker-options {
  /*  margin-top: 10px !important;  Un poco de aire */
    border-radius: 8px !important;

    box-shadow: 0 4px 15px rgba(0,0,0,0.2) !important;
}

/* Estilo del editor principal */
#editor-container {
    height: 100px; /* Un poco más alto para comodidad */
    background: white;
    border-radius: 0 0 12px 12px;
    border: 1px solid var(--color-border);
    border-top: none;
}

/* --- 4. EDITOR EN MODO EDICIÓN DE NOTA (Optimizado) --- */
.editing-quill-wrapper .ql-toolbar {
    border-radius: 8px 8px 0 0;
    background: #eef2f5; /* Un tono diferente para distinguir edición */
}
.editing-quill-container {
    background: #fff;
    min-height: 100px;
    border: 1px solid #ccc;
    border-top: none;
    border-radius: 0 0 8px 8px;
}
     
      
      
      

      
  
      
      
      
/* --- ESTILOS MEJORADOS MENÚ DESCARGA --- */
.download-wrapper {
    position: relative;
    display: inline-block;
}

.download-dropdown-menu {
    position: absolute;
    bottom: 120%; /* Un poco más separado del botón */
    right: 0;
    width: 200px; /* Ancho fijo para que no se deforme */
    background: #ffffff;
    border: 1px solid rgba(0,0,0,0.08);
    border-radius: 12px; /* Bordes más redondeados */
    box-shadow: 0 10px 30px rgba(0,0,0,0.15); /* Sombra suave y moderna */
    padding: 8px;
    z-index: 9999;
    display: none;
    flex-direction: column;
    opacity: 0;
    transform: translateY(-10px);
    transition: all 0.2s ease-in-out;
}

.download-dropdown-menu.visible {
    display: flex;
    opacity: 1;
    transform: translateY(0);
}

.download-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    border: none;
    background: transparent;
    width: 100%;
    text-align: left;
    cursor: pointer;
    font-size: 0.95rem;
    font-family: 'Poppins', sans-serif;
    color: #444;
    border-radius: 8px;
    transition: all 0.2s;
}

.download-option:hover {
    background-color: #f5f7fa;
    color: #8a4dff; /* Tu color primario */
    transform: translateX(3px); /* Pequeño movimiento al pasar el mouse */
}

.download-option i {
    width: 24px;
    text-align: center;
    font-size: 1.1rem;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
}      
      
      
      
      

      
      
      
/* --- ESTILOS DEL LOADER MODERNO --- */
.download-loader-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(222, 238, 255, 0.1); /* Fondo oscuro elegante */
    backdrop-filter: blur(8px); /* Efecto Glass */
    z-index: 99999; /* Por encima de todo */
    display: none; /* Oculto por defecto */
    flex-direction: column;
    justify-content: center;
    align-items: center;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.download-loader-overlay.visible {
    display: flex;
    opacity: 1;
}

.loader-card {
    background: white;
    padding: 2rem;
    border-radius: 20px;
    box-shadow: 0 15px 40px rgba(0,0,0,0.3);
    text-align: center;
    width: 320px;
    position: relative;
    overflow: hidden;
}

.loader-icon {
    font-size: 3rem;
    color: var(--color-primary);
    margin-bottom: 1rem;
    animation: bounce 2s infinite;
}

.loader-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--color-text-primary);
    margin-bottom: 0.5rem;
}

.loader-subtitle {
    font-size: 0.85rem;
    color: var(--color-text-secondary);
    margin-bottom: 1.5rem;
}

/* Barra de Progreso */
.progress-track {
    width: 100%;
    height: 8px;
    background: #f0f2f7;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--color-primary) 0%, #a875ff 100%);
    width: 0%;
    border-radius: 10px;
    transition: width 0.2s linear;
    position: relative;
}

/* Brillo animado en la barra */
.progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    background: linear-gradient(
        45deg,
        rgba(255,255,255,0.2) 25%,
        transparent 25%,
        transparent 50%,
        rgba(255,255,255,0.2) 50%,
        rgba(255,255,255,0.2) 75%,
        transparent 75%,
        transparent
    );
    background-size: 20px 20px;
    animation: moveStripes 1s linear infinite;
}

.progress-text {
    margin-top: 10px;
    font-size: 0.9rem;
    font-weight: 700;
    color: var(--color-primary);
}

@keyframes moveStripes {
    0% { background-position: 0 0; }
    100% { background-position: 20px 20px; }
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-10px); }
    60% { transform: translateY(-5px); }
}

/* --- AJUSTES PARA EL RESIZER DE IMAGENES QUILL --- */
/* Asegura que los manejadores de redimensión se vean bien */
#editor-container img, 
.editing-quill-container img,
.import-quill-editor-container img {
    display: inline-block; /* Necesario para que el plugin detecte */
}
/* Videos responsivos dentro del editor */
.ql-video {
    max-width: 100%;
}      
      
      
      

      
      
/* --- NUEVO: ESTILOS PARA INTERLINEADO (LINE HEIGHT) --- */
.ql-snow .ql-picker.ql-lineheight .ql-picker-label::before,
.ql-snow .ql-picker.ql-lineheight .ql-picker-item::before {
    content: attr(data-value);
}
.ql-snow .ql-picker.ql-lineheight .ql-picker-label[data-value=""]::before,
.ql-snow .ql-picker.ql-lineheight .ql-picker-item[data-value=""]::before {
    content: "Normal";
}
.ql-snow .ql-picker.ql-lineheight {
    width: 90px; /* Ancho para que quepa el texto */
}

/* --- NUEVO: SOLUCIÓN VIDEO (EDITAR VS VER) --- */
/* Cuando estamos EDITANDO (dentro del editor Quill), desactivamos 
   los clics dentro del iframe para que el plugin de resize pueda seleccionarlo 
.ql-editor iframe {
    pointer-events: none; 
    border: 1px solid transparent;
}
 Cuando el video está seleccionado para redimensionar, le damos un borde visual
.ql-editor iframe[data-display="block"] {
    border: 2px solid var(--color-primary);
}*/
      
/* Asegura que la máscara de selección de BlotFormatter esté siempre visible */
.blot-formatter__overlay {
    z-index: 100 !important; /* Por encima del video */
    background-color: rgba(138, 77, 255, 0.1) !important; /* Tinte morado suave al seleccionar */
}

/* Opcional: Para que el video no se reproduzca mientras lo redimensionas en móvil */
.ql-editor iframe {
    pointer-events: auto; /* Dejamos auto, BlotFormatter pondrá un div encima */
}      
      
      
      
      
      
      

/* Cuando estamos VIENDO (nota guardada), reactivamos los clics para Play/Pause */
.note-text-display iframe, 
.import-note-content iframe,
.popup-content-wrapper iframe {
    pointer-events: auto !important;
    max-width: 100%;
}

/* Asegurar relación de aspecto (aunque el plugin maneja width/height, esto ayuda en móvil) */
.note-text-display .ql-video {
    aspect-ratio: 16 / 9;
    height: auto; 
}      
      
      
      
      
      
      
      
      
      
      
      
      
      
 
      
/* --- MEJORA PARA RESIZE DE VIDEOS (IFRAMES) --- */

/* Permitir alineación correcta de videos e imágenes */
#editor-container .ql-editor, 
.editing-quill-container .ql-editor,
.import-quill-editor-container .ql-editor {
    text-align: left; /* Base */
}

/* Hacer que los videos respondan a la alineación del plugin */
.ql-editor iframe.ql-video {
    pointer-events: none; /* TRUCO: Desactiva clics DENTRO del video para poder seleccionarlo */
    border: 1px solid transparent; /* Borde invisible para ayudar a la selección */
    transition: all 0.2s ease;
    border-radius: 15px;
}

/* Cuando el editor NO está enfocado, reactivar pointer-events para poder dar play (opcional) */
/* Pero para editar tamaño, es mejor mantenerlo desactivado o usar el overlay del plugin */

/* Asegurar que el alineamiento funcione */
.ql-editor .ql-align-center { text-align: center; }
.ql-editor .ql-align-right { text-align: right; }
.ql-editor .ql-align-justify { text-align: justify; }

/* Importante para exportación PDF/Word */
img, iframe {
    max-width: 100%; /* Evita desbordes, pero permite ser más pequeño */
}      
      
      
      
/* --- CORRECCIÓN VISUAL PARA IMPORTACIÓN --- */
.import-note-content .ql-editor {
    padding: 0 !important; /* Quitar padding nativo de Quill para que no ocupe mucho espacio */
    overflow-y: visible !important;
    min-height: auto !important;
    font-size: 0.9rem; /* Un poco más pequeño para la lista compacta */
    color: var(--color-text-secondary);
    line-height: 1.5;
}

/* Asegurar que las imágenes importadas no rompan el modal */
.import-note-content .ql-editor img {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
    display: block;
    margin: 5px 0;
}

/* Separar visualmente el título de la nota del contenido */
.import-note-title-badge {
    display: inline-block;
    font-weight: 700;
    color: var(--color-text-primary);
    margin-right: 5px;
    margin-bottom: 4px;
}
      
      
      
/* --- NUEVO: ESTILOS PARA BUSCADOR Y RESALTADO --- */

/* 1. Estilo para el texto encontrado */
.search-highlight {
    background-color: #ffeeba; /* Fondo amarillo suave */
    color: #856404; /* Texto oscuro para contraste */
    font-weight: bold;
    border-bottom: 2px solid #ffc107;
    padding: 0 2px;
    border-radius: 2px;
    box-shadow: 0 0 5px rgba(255, 193, 7, 0.4);
}

/* 2. Hacer que el icono de la lupa parezca un botón */
.notes-search-input-container i {
    cursor: pointer;
    pointer-events: auto; /* Asegura que reciba clics */
    transition: all 0.2s ease;
    z-index: 5; /* Asegurar que esté sobre el input */
    padding: 5px; /* Aumentar área de clic */
}
.notes-search-input-container i:hover {
    transform: translateY(-50%) scale(1.2);
}

/* 3. Feedback visual al input al buscar */
#notes-smart-search.searching {
    border-color: var(--color-primary);
    background-color: #f0f7ff;
}      
      
      
      
      
.ql-container.ql-snow {
overflow: auto;
}      
      
      
      
      
      
      
/* --- NUEVOS ESTILOS: BUSCADOR Y POPUP DE NOTAS --- */

/* 1. Buscador Inteligente de Notas */
.notes-search-wrapper {
    padding: 0 0.5rem 0.8rem 0.5rem;
    border-bottom: 1px solid var(--color-border);
    margin-bottom: 0.5rem;
    position: sticky;
    top: 0;
    background: var(--color-surface); /* Sticky header */
    z-index: 10;
}

.notes-search-input-container {
    position: relative;
    width: 100%;
}

.notes-search-input-container i {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 0.9rem;
    background: var(--color-primary);
    border-radius: 5px;
}

#notes-smart-search {
    width: 100%;
    padding: 0.6rem 2.2rem 0.6rem 0.6rem;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    font-size: 0.85rem;
    background-color: #f8f9fa;
    transition: all 0.3s ease;
}

#notes-smart-search:focus {
    background-color: #fff;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(138, 77, 255, 0.1);
    outline: none;
}

/* 2. Botón para abrir Popup (Nuevo icono) */
.open-popup-btn {
    color: var(--color-text-secondary);
}
.open-popup-btn:hover {
    color: var(--color-primary);
    background-color: var(--color-primary-light);
}

/* 3. Contenedor de la Nota Flotante */
.floating-note-popup {
    position: fixed;
    z-index: 9999;
    background: #fff;
    border: 1px solid var(--color-border);
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-width: 300px;
    min-height: 200px;
    width: 400px; /* Tamaño inicial PC */
    height: 300px;
    resize: both; /* Permite redimensionar en PC */
    overflow: auto;
    transition: box-shadow 0.2s, transform 0.1s;
    animation: popupFadeIn 0.2s ease-out;
}

.floating-note-popup.active-drag {
    box-shadow: 0 15px 50px rgba(138, 77, 255, 0.25);
    border-color: var(--color-primary);
    opacity: 0.95;
}

@keyframes popupFadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

/* Header del Popup (Arrastrable) */
.floating-note-header {
    padding: 0.8rem 1rem;
    background: #f8f9fa;
    border-bottom: 1px solid var(--color-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab; /* Manito para arrastrar */
    user-select: none;
    flex-shrink: 0;
}
.floating-note-header:active {
    cursor: grabbing;
    background: #edf2f7;
}

.floating-drag-handle {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--color-text-secondary);
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Cuerpo del Popup */
.floating-note-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    background: #fff;
}

/* Estructura Interna del Popup (Top Actions / Bottom Content) */
.popup-actions-wrapper {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px dashed var(--color-border);
}

.popup-content-wrapper {
    flex-grow: 1;
}

.popup-content-wrapper .note-text-display {
    font-size: 1rem; /* Un poco más grande para lectura cómoda */
}

/* Botón cerrar del header */
.close-floating-btn {
    border: none;
    background: none;
    color: var(--color-text-secondary);
    cursor: pointer;
    width: 24px; height: 24px;
    border-radius: 50%;
    display: grid;
    place-items: center;
    transition: all 0.2s;
}
.close-floating-btn:hover { background: #fee2e2; color: #ef4444; }

/* RESPONSIVE: MÓVIL (Fullscreen) */
@media (max-width: 768px) {
    .floating-note-popup {
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        border-radius: 0;
        resize: none; /* Desactivar resize en móvil */
        border: none;
    }
    .floating-note-header {
        cursor: default; /* No se arrastra en móvil */
        padding: 1rem;
    }
    .floating-drag-handle span {
        content: "Vista de Nota"; /* Texto alternativo visual */
    }
}
      
      

      
      
      
      
/* --- 1. REESTRUCTURACIÓN DE NOTE-ITEM (Botones arriba, contenido abajo) --- */
.note-item {
    display: flex;
    flex-direction: column-reverse; /* Invertimos: Contenido abajo, Actions arriba (visual) */
    gap: 1rem !important;
    position: relative; /* Espacio reservado para los botones absolutos */
}

/* Los botones se posicionan absolutamente arriba a la derecha */
/*.note-item-actions-display {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 0.25rem;
    z-index: 5;
}*/

/* El contenido ocupa todo el ancho */
.note-content-display {
    width: 100%;
}

/* Ajuste del header (Timestamp y Título) para que no choque con los botones */
.note-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}


/* --- 2. MEJORA VISUAL DEL POPUP FLOTANTE --- */
.floating-note-popup {
    min-width: 320px;
    min-height: 250px;
    display: flex;
    flex-direction: column;
    /* IMPORTANTE: Quitamos resize:both nativo porque usaremos JS para controlar el iframe */
    resize: none; 
    overflow: hidden; 
    padding-bottom: 0; 
    box-shadow: 0 15px 50px rgba(0,0,0,0.3);
}

/* Indicador visual y funcional de Redimensionamiento */
.floating-resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 20px;
    height: 20px;
    /* Triángulo en la esquina */
    background: linear-gradient(135deg, transparent 50%, var(--color-primary) 50%);
    cursor: nwse-resize; 
    z-index: 50; /* Por encima de todo */
    border-radius: 0 0 12px 0;
}

/* IMPORTANTE: Esto permite arrastrar/redimensionar sobre YouTube suavemente */
body.is-dragging-popup iframe {
    pointer-events: none !important;
}

/* Ajustes del Editor dentro del Popup */
.popup-editor-container {
    display: flex; 
    flex-direction: column; 
    height: 100%; 
    gap: 10px;
}
.popup-quill-wrapper {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    background: #fff;
    border: 1px solid var(--color-border);
    border-radius: 8px;
}
.popup-quill-editor {
    flex-grow: 1;
    overflow-y: auto;
    border: none !important;
}      
      
      
/* --- AGREGAR ESTO AL FINAL DE TUS ESTILOS CSS --- */

/* Cuando se arrastra o redimensiona el popup: */
body.is-dragging-popup {
    user-select: none !important; /* Evita que se seleccione texto en la página */
    -webkit-user-select: none !important; /* Safari */
    cursor: grabbing !important; /* Mantiene el cursor de agarre */
}

body.is-dragging-popup iframe {
    pointer-events: none !important; /* Ya lo tenías, evita que el mouse entre al iframe */
}         
      
      
      
      
      
      
      
      
   
      
      
      
 /* ======================================================= */
/* === 1. ESTILOS CORREGIDOS CARRUSEL DE ARCHIVOS (MODAL) === */
/* ======================================================= */
.file-slider-wrapper {
    position: relative; /* Necesario para posicionar flechas */
    display: flex;
    align-items: center;
    background: #fff;
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 5px 35px; /* Espacio para las flechas */
    margin-top: 10px;
    height: 56px;
}

.file-list-display {
    display: flex;
    gap: 10px;
    overflow-x: auto;
    flex-grow: 1;
    height: 100%;
    align-items: center;
    scrollbar-width: none; /* Ocultar scrollbar nativa */
    cursor: grab;
    user-select: none;
}
.file-list-display.grabbing { cursor: grabbing; }
.file-list-display::-webkit-scrollbar { display: none; }

/* Flechas Carrusel Visibles */
.file-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 28px;
    height: 28px;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 50%;
    display: none; /* JS las activa */
    place-items: center;
    cursor: pointer;
    z-index: 10;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    color: var(--color-text-primary);
}
.file-arrow:hover { background-color: var(--color-bg); }
#file-arrow-left { left: 5px; }
#file-arrow-right { right: 5px; }

/* Etiquetas de Archivo */
.file-tag {
    background: var(--color-primary-light);
    color: var(--color-primary);
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 0.85rem;
    white-space: nowrap;
    border: 1px solid #d6bcfa; /* Borde suave */
    display: flex;
    align-items: center;
    gap: 6px;
    font-weight: 500;
}

/* ======================================================= */
/* === 2. ESTILOS QUICK VIEW (SOLUCIÓN MÓVIL SCROLL) === */
/* ======================================================= */
.quick-view-body { display: flex; height: 100%; overflow: hidden; }
.quick-view-video { flex: 2; background: #000; display: flex; align-items: center; justify-content: center; }
.quick-view-notes { flex: 1; border-left: 1px solid var(--color-border); display: flex; flex-direction: column; background: var(--color-bg); min-width: 350px; }

/* PC / Tablet: Scroll interno solo en la lista */
.quick-notes-list { flex-grow: 1; overflow-y: auto; padding: 1rem; display: flex; flex-direction: column; gap: 0.8rem; background-color: var(--color-bg); }
.quick-notes-footer { flex-shrink: 0; padding: 1rem; background: var(--color-surface); border-top: 1px solid var(--color-border); display: flex; flex-direction: column; gap: 1rem; }
#quick-player-container { width: 100%; height: 100%; }

/* MÓVIL: Video arriba fijo, Notas + Footer scrollean juntos abajo */
@media (max-width: 900px) {
    .quick-view-modal { max-width: 100vw !important; height: 100vh !important; border-radius: 0; }
    .quick-view-body { flex-direction: column; }
    
    .quick-view-video { 
        flex: 0 0 auto; 
        height: 35vh; /* Altura fija para video */
        min-height: 200px;
    }
    
    .quick-view-notes { 
        flex: 1; 
        border-left: none; 
        border-top: 1px solid var(--color-border);
        overflow-y: auto; /* SCROLL EN EL CONTENEDOR PADRE */
        display: block; /* Deja de ser flex column para permitir flujo normal */
    }
    
    .quick-notes-list {
        overflow: visible; /* Quita scroll interno */
        height: auto; 
        flex-grow: 0;
    }
    
    .quick-notes-footer {
        position: static; /* Se mueve con el scroll */
        border-top: 1px solid var(--color-border);
        padding-bottom: 2rem; /* Espacio extra abajo */
    }
}

/* ======================================================= */
/* === 3. ESTILOS IMPORTACIÓN (BOTONES CHECK/X) === */
/* ======================================================= */
.import-pending-actions { display: flex; gap: 5px; justify-content: flex-end; margin-left: auto; }
.btn-accept-import { background: var(--color-success); color: white; border: none; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; display: grid; place-items: center; transition: transform 0.2s;}
.btn-reject-import { background: var(--color-error); color: white; border: none; width: 32px; height: 32px; border-radius: 6px; cursor: pointer; display: grid; place-items: center; transition: transform 0.2s;}
.btn-accept-import:hover { background-color: #43a047; transform: scale(1.1); }
.btn-reject-import:hover { background-color: #d32f2f; transform: scale(1.1); }

/* Nota oculta (Des-seleccionada) */
.import-note-item.is-hidden-note { opacity: 0.5; background-color: #f1f1f1; }
.import-note-item.is-hidden-note .import-note-content p { text-decoration: line-through; color: #999; }
.import-note-item.is-hidden-note .import-note-content small { filter: grayscale(1); }     
      
      
      

      
      
      
/* CSS OBLIGATORIO PARA QUE SE VEA EL NÚMERO DEL INTERLINEADO */
.ql-snow .ql-picker.ql-lineheight .ql-picker-label::before {
    content: attr(data-value) !important;
}
/* Cuando no hay valor (es normal), mostramos "Normal" o el icono por defecto */
.ql-snow .ql-picker.ql-lineheight .ql-picker-label[data-value=""]::before,
.ql-snow .ql-picker.ql-lineheight .ql-picker-label:not([data-value])::before {
    content: "Normal" !important;
}
/* Ajuste de ancho para que quepa la palabra "Normal" */
.ql-snow .ql-picker.ql-lineheight {
    width: 90px !important;
}      
      
      
      
      
      
      
      
      
      
      
      
   

      
/* ======================================================= */
/* === SEGURIDAD Y ESTADOS DE ACCESO (NUEVO) === */
/* ======================================================= */

/* 1. Ocultar todo el sitio inicialmente por seguridad */
/* El JS quitará esta clase una vez verifique el Status */
body.security-check-pending {
    display: none !important;
}

/* 2. Estilo para Elementos Bloqueados (Gris + Candado) */
.locked-item {
    background-color: #f0f2f5 !important; /* Fondo plomo suave */
    color: #a0aec0 !important; /* Texto gris */
    cursor: not-allowed !important;
    position: relative;
    opacity: 0.8;
    border-color: #e2e8f0 !important;
}

/* Evitar interacción con elementos bloqueados */
.locked-item * {
    pointer-events: none; /* Nadie puede hacer clic dentro */
}

/* Icono del Candado Dorado */
.locked-icon {
    color: #d69e2e !important; /* Dorado */
    margin-right: 6px;
    font-size: 0.9rem;
    display: inline-block;
}

/* 3. Estilos específicos para TABS bloqueados */
.tab-button.locked-item {
    box-shadow: none;
}
.tab-button.locked-item:hover {
    background-color: #f0f2f5 !important;
    transform: none !important;
}

/* 4. Estilos específicos para SIDEBAR (Subtemas) bloqueados */
.subtopic-item.locked-item {
    border-left: 3px solid transparent;
}
.subtopic-item.locked-item .subtopic-check-icon {
    color: #cbd5e0 !important; /* Check gris si está bloqueado */
}
.subtopic-item.locked-item:hover {
    background-color: #f0f2f5 !important;
}

/* 5. Tooltip de Seguridad (Rojo/Dorado) */
.security-tooltip {
    background-color: #2d3748 !important;
    border-left: 3px solid #d69e2e; /* Borde dorado */
}
.security-tooltip i {
    color: #d69e2e;
    margin-right: 5px;
}

/* 6. Ocultar botones de Notas si no tiene permisos (No usamos display:none por seguridad en JS, pero esto ayuda visualmente) */
.restricted-access {
    display: none !important;
}      
      
      
/* --- FIX CRÍTICO: VISIBILIDAD EN EDICIÓN --- */
/* Forza a mostrar el editor y ocultar el texto cuando se activa la clase .is-editing */
.note-item.is-editing .note-content-display,
.note-item.is-editing .note-item-actions-display {
    display: none !important;
}
.note-item.is-editing .note-content-edit,
.note-item.is-editing .note-item-actions-edit {
    display: block !important; 
}
.note-item.is-editing .note-item-actions-edit {
    display: flex !important; /* Para que los botones se alineen bien */
}

/* --- FIX DE MENÚS CORTADOS (OVERFLOW) --- */
/* Esto permite que los menús desplegables salgan del acordeón */
.note-accordion-content.allow-overflow {
    overflow: visible !important;
}

/* Ajuste fino para la barra carrusel */
.ql-toolbar.ql-snow {
    padding: 6px !important;
    gap: 5px;
}
.ql-formats {
    margin-right: 10px !important;
}      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
        /* === LOGICA DE INTERACCION POR TAMAÑO DE PANTALLA === */

        /* 1. PC GRANDE (> 1400px) 
           - Botón toggle OCULTO.
           - Hover EXPANDIR AUTOMATICO.
        */
        @media (min-width: 1401px) {
            .sidebar-footer { display: none !important; } /* Botón toggle eliminado */

            /* Al pasar el mouse sobre sidebar colapsado, se expande visualmente */
            .app-sidebar.collapsed:hover {
                width: var(--sidebar-width-expanded) !important;
            }

            /* Restaurar visualización de elementos al hacer hover */
            .app-sidebar.collapsed:hover .logo-text, 
            .app-sidebar.collapsed:hover .search-bar-container,
           .app-sidebar.collapsed:hover .topic-header,
            .app-sidebar.collapsed:hover .subtopic-title,
            .app-sidebar.collapsed:hover .topic-toggle-icon {
                display: flex !important;
            }
            
            /* Ajustes de layout al hacer hover */
            .app-sidebar.collapsed:hover .sidebar-header { justify-content: space-between; padding: 0 1rem; }
            .app-sidebar.collapsed:hover .sidebar-logo { justify-content: flex-start; width: auto; }
            .app-sidebar.collapsed:hover .sidebar-filters { justify-content: flex-start; padding: 1rem; }
            
            .app-sidebar.collapsed:hover .subtopic-list {
                display: block; /* Volver a layout normal de lista */
                padding-left: 0.75rem;
            }
            .app-sidebar.collapsed:hover .subtopic-item {
                justify-content: flex-start;
                width: auto;
                height: auto;
                border-radius: 8px;
            }
            
            /* Importante: El acordeón lógico se mantiene. Si estaba cerrado, sigue cerrado, 
               pero si estaba abierto, se muestra el contenido */
            .app-sidebar.collapsed:hover .subtopic-list {
                /* Resetear estilos forzados del modo colapsado */
                flex-direction: column;
                align-items: stretch;
                gap: 0;
                padding-top: 0;
            }
            /* Ocultar lista si el grupo NO está open al hacer hover */
            .app-sidebar.collapsed:hover .topic-group:not(.open) .subtopic-list {
                display: none !important; 
            }
            .app-sidebar.collapsed:hover .topic-group.open .subtopic-list {
                 display: block !important;
                 max-height: 100%;
            }
        }

        /* 2. TABLET / LAPTOP PEQUEÑA (1100px - 1400px)
           - Botón toggle VISIBLE y funcional.
           - Hover DESACTIVADO (no hace nada).
        */
        @media (max-width: 1400px) and (min-width: 1100px) {
          
            /* El botón toggle debe ser visible */
            .sidebar-footer { display: flex !important; }
            
            /* El hover no debe disparar nada, así que no añadimos reglas :hover aquí.
               La clase .collapsed se controla exclusivamente vía JS click en botón */
        }

        /* 3. MÓVIL (< 1100px) 
           - Sidebar Off-canvas.
           - Estado 'collapsed' (iconos) NO existe, desaparece.
        */
        
        /* --- HEADER MÓVIL --- */
        .app-header-mobile {
            display: none;
            height: var(--header-height);
            background-color: var(--color-surface);
            border-bottom: 1px solid var(--color-border);
            align-items: center;
            padding: 0 1rem;
            gap: 0.75rem;
            position: sticky;
            top: 0;
            z-index: 90;
        }
        .app-header-mobile #mobile-menu-btn {
            background: none;
            border: none;
            color: var(--color-primary);
            font-size: 1.2rem;
            cursor: pointer;
            width: 35px;
            height: 35px;
            display: grid;
            place-items: center;
        }
        .app-header-mobile .sidebar-logo {
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .app-header-mobile .sidebar-logo img { width: 30px; height: 30px; }
        .app-header-mobile .sidebar-logo .logo-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--color-text-primary);
        }

        @media (max-width: 1100px) {
            .app-content {
                margin-left: 0; /* Sin margen izquierdo */
                width: 100%;
            }

            /* Sidebar fuera de pantalla por defecto */
            .app-sidebar {
                transform: translateX(-100%);
                width: var(--sidebar-width-expanded); 
                box-shadow: none; 
                transition: transform 0.25s cubic-bezier(0.2, 0, 0, 1);
               /* transition: transform 0.3s ease;  Solo animamos la entrada */
            }
            
            /* Sidebar abierto en móvil */
            .app-sidebar.mobile-open {
                transform: translateX(0);
                box-shadow: 5px 0 30px rgba(0,0,0,0.2);
            }

            /* En móvil, 'collapsed' no significa "iconos", significa "ancho completo" cuando se abre.
               Sobrescribimos los estilos de .collapsed para que se vea normal si la clase está presente */
            .app-sidebar.collapsed {
                width: var(--sidebar-width-expanded);
            }
            .app-sidebar.collapsed .logo-text, 
            .app-sidebar.collapsed .search-bar-container,
            .app-sidebar.collapsed .topic-header, 
            .app-sidebar.collapsed .toggle-text,
            .app-sidebar.collapsed .subtopic-title,
            .app-sidebar.collapsed .topic-toggle-icon { display: flex !important; /*display: block !important; */}
            .app-sidebar.collapsed .topic-toggle-icon { display: block !important; }
            .app-sidebar.collapsed .sidebar-header { justify-content: space-between; padding: 0 1rem; }
            .app-sidebar.collapsed .sidebar-logo { justify-content: flex-start; width: auto; }
            .app-sidebar.collapsed .subtopic-list { display: block; padding-left: 0.75rem; max-height: 0 !important; overflow: hidden; transition: max-height 0.25s cubic-bezier(0.4, 0, 0.2, 1), padding 0.2s ease !important; /*transition: max-height 0.3s ease-out, padding 0.3s ease !important*/; flex-direction: column; align-items: stretch; gap: 0; padding-top: 0; }
            .app-sidebar.collapsed .topic-group.open .subtopic-list { max-height: 100% !important; /*max-height: 1500px !important;*/ }

            .app-sidebar.collapsed .subtopic-item { justify-content: flex-start; width: auto; height: auto; border-radius: 8px; }
            
            /* Restaurar botón de toggle en móvil si estaba colapsado (aunque ocultamos el footer móvil) */
            .app-sidebar.collapsed .sidebar-footer {
                 justify-content: flex-end;
                 padding: 1rem;
                 border-top: 1px solid var(--color-border);
            }
            .app-sidebar.collapsed #sidebar-toggle-btn {
                width: auto;
                padding: 0 0.75rem;
                display: flex;
            }
            .app-sidebar.collapsed #sidebar-toggle-btn i { transform: rotate(0deg); }

            .app-header-mobile { display: flex; }
            
            #sidebar-close-btn {
                display: grid;
                background: none;
                border: none;
                color: var(--color-text-secondary);
                font-size: 1.2rem;
                cursor: pointer;
                width: 35px;
                height: 35px;
                border-radius: 8px;
                place-items: center;
            }
            #sidebar-close-btn:hover { background-color: var(--color-bg); }

            .sidebar-footer { display: none !important; } /* Ocultar footer en móvil */
        }

        /* --- VVV NUEVO MODAL DE FILTROS VVV --- */
        .filter-modal-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }
        .filter-modal-backdrop.visible { display: flex; }
        .filter-modal {
            background: var(--color-surface);
            border-radius: var(--border-radius);
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .filter-modal-header {
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .filter-modal-header h3 { font-size: 1.2rem; }
        .filter-modal-body {
            padding: 1.5rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .filter-group h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--color-text-primary);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .filter-options { display: flex; flex-wrap: wrap; gap: 0.75rem; }
        .filter-options label {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--color-bg);
            padding: 0.6rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }
        .filter-options input[type="radio"],
        .filter-options input[type="checkbox"] { display: none; }
        .filter-options input:checked + span { color: var(--color-primary); font-weight: 600; }
        .filter-options label:has(input:checked) { background-color: var(--color-primary-light); box-shadow: 0 0 0 1px var(--color-primary); }
        
        #filter-subtopics-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 0.5rem;
        }
        #filter-subtopics-list label { background: none; width: 100%; }
        #filter-subtopics-list label:hover { background: var(--color-bg); }
        #filter-subtopics-list label:has(input:checked) { background: var(--color-bg); }
        
        .filter-modal-footer {
            padding: 1.25rem 1.5rem;
            border-top: 1px solid var(--color-border);
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            background-color: #fcfdff;
        }

        /* --- CONTENEDOR PRINCIPAL --- */
        .main-container { 
            display: grid; 
            grid-template-columns: 71% 27%; 
            gap: 2%; 
            width: 100%; 
            padding: 1rem; 
            max-width: 1800px; 
            margin: 0 auto; 
            transition: grid-template-columns 0.3s ease; 
        }
        .left-column { display: flex; flex-direction: column; gap: 1.5rem; }
        .right-column { position: sticky; top: 2rem; height: calc(100vh - 4rem); }
        .card { background-color: var(--color-surface); border-radius: var(--border-radius); box-shadow: var(--shadow); padding: 1.5rem; display: flex; flex-direction: column; }

        .button { padding: 0.8rem 1.5rem; border: none; border-radius: 8px; font-weight: 600; font-size: 0.9rem; cursor: pointer; transition: all 0.3s; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; text-decoration: none; }
        .button:hover:not(:disabled) { opacity: 0.85; transform: translateY(-2px); }
        .button-primary { background-color: var(--color-primary); color: white; box-shadow: 0 4px 12px rgba(138, 77, 255, 0.3); }
        .button-secondary { background-color: var(--color-bg); color: var(--color-text-primary); }
        .button-secondary:hover { background-color: #e5e7ed; }

        /* --- COLUMNA IZQUIERDA --- */
        .video-section.card { padding: 0; background-color: transparent; box-shadow: none; }
        .video-player-container { position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: var(--border-radius); background-color: #000; }
        .video-player-container iframe { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        .info-section.card h1 { font-size: 1.8rem; font-weight: 600; margin-bottom: 0.5rem; line-height: 1.2; }
        .info-section.card .video-meta { color: var(--color-text-secondary); font-size: 0.9rem; margin-bottom: 1.5rem; }

        .channel-info { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--color-border); flex-wrap: wrap; gap: 1rem; }
        .channel-details { display: flex; align-items: center; gap: 1rem; }
        .channel-details img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: var(--color-border); }
        .channel-name span { font-weight: 600; font-size: 1.1rem; }
        .channel-name small { color: var(--color-text-secondary); font-size: 0.85rem; display: block; }
        .channel-actions { display: flex; align-items: center; gap: 0.75rem; }
        
        .like-icon-button { background: transparent; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; display: grid; place-items: center; font-size: 1.2rem; color: var(--color-text-primary); transition: all 0.3s ease; }
        .like-icon-button:hover { background-color: var(--color-error-light); }
        .like-icon-button.liked { color: var(--color-error); }
        
        .custom-subscribe-btn { background-color: #CC0000; color: white; padding: 0.7rem 1.2rem; border-radius: 20px; text-decoration: none; font-weight: 600; font-size: 0.9rem; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.3s ease; }
        .custom-subscribe-btn:hover { background-color: #E62117; transform: translateY(-2px); }
        .custom-subscribe-btn i { font-size: 1.1rem; }

        .description-content { background-color: var(--color-bg); padding: 1.25rem; border-radius: 12px; }
        .description-content p { line-height: 1.7; color: var(--color-text-secondary); font-size: 0.9rem; }

        /* --- CARRUSEL DE LÍNEA DE TIEMPO --- */
        .video-timeline-carousel { 
            margin-top: 1.5rem; 
            border-top: 1px solid var(--color-border); 
            padding-top: 1.5rem; 
        }
        .video-timeline-carousel h3 {
            font-size: 1.1rem;
            color: var(--color-text-primary);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .video-timeline-carousel h3 i { color: var(--color-primary); }

        .timeline-slider-container { position: relative; }

        .timeline-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 2;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: grid;
            place-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: opacity 0.3s, transform 0.3s;
        }
        .timeline-arrow:hover { transform: translateY(-50%) scale(1.1); background-color: var(--color-bg); }
        #timeline-slide-left-btn { left: -18px; }
        #timeline-slide-right-btn { right: -18px; }

        .timeline-items-wrapper {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            padding-bottom: 10px; 
            margin-bottom: -10px; 
            gap: 1rem;
            scrollbar-width: none;
            scroll-behavior: smooth;
            cursor: grab;
            user-select: none;
        }
        .timeline-items-wrapper.grabbing { cursor: grabbing; scroll-snap-type: none; }
        .timeline-items-wrapper::-webkit-scrollbar { display: none; }

        .timeline-item {
            flex: 0 0 auto;
            width: 180px;
            scroll-snap-align: start;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow);
            background-color: var(--color-surface);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-decoration: none;
            color: var(--color-text-primary);
            display: flex;
            flex-direction: column;
            margin-top: 15px;
        }
        .timeline-item:hover { transform: translateY(-5px); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); }

        .timeline-thumbnail {
            width: 100%;
            height: 100px;
            background-color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            pointer-events: none;
        }
        .timeline-thumbnail img { width: 100%; height: 100%; object-fit: cover; display: block; }

        .timeline-content {
            padding: 0.8rem;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
            pointer-events: none;
        }
        .timeline-content .timestamp { font-size: 0.85rem; font-weight: 600; color: var(--color-primary); margin-bottom: 0.4rem; }
        .timeline-content .title {
            font-size: 0.9rem;
            font-weight: 500;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- COMENTARIOS FACEBOOK --- */
        .comments-section.card { padding: 1.5rem; }
        .comments-section.card h2 {
            font-size: 1.3rem;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--color-text-primary);
        }
        .comments-section.card h2 i { color: #1877F2; }

        p.comments-motivation-message {
            background-color: var(--color-primary-light);
            color: var(--color-text-primary);
            padding: 1rem 1.25rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            line-height: 1.6;
            text-align: center;
            box-shadow: inset 0 0 0 1px var(--color-primary);
        }
        p.comments-motivation-message strong { color: var(--color-primary); }
        .fb-comments-container { width: 100%; min-height: 300px; }
        .fb-comments, .fb-comments iframe[style] { width: 100% !important; }

        /* --- COLUMNA DERECHA (INTERACTIVA) --- */
        .interactive-section.card { height: 100%; overflow: hidden; padding: 1.5rem; }
        .tabs-slider-container { position: relative; margin-top: -1rem; z-index: 70; background: white; padding: 1rem 0rem; }
        .tabs-slider-container .slider-arrow { position: absolute; top: 50%; transform: translateY(-50%); z-index: 2; background-color: var(--color-bg); border: 1px solid var(--color-border); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: none; place-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.3s, transform 0.3s; }
        .tabs-slider-container .slider-arrow:hover { background-color: var(--color-surface); transform: translateY(-50%) scale(1.1); }
        .tabs-slider-container .slider-arrow#slide-left-btn { left: -16px; }
        .tabs-slider-container .slider-arrow#slide-right-btn { right: -16px; }
        .tabs-slider-container.is-scrollable .slider-arrow { display: grid; }
        
        #reorder-tabs-btn {
            display: none;
            position: absolute;
            z-index: 3;
            background-color: var(--color-bg);
            border: 1px solid var(--color-border);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            place-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            color: var(--color-text-primary);
            font-size: 0.9rem;
            top: 0;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .tabs-slider-container.is-scrollable #reorder-tabs-btn { display: none; }
        #reorder-tabs-btn:hover { background-color: var(--color-surface); }
        
        .tabs { display: flex; user-select: none; overflow-x: auto; scroll-behavior: smooth; flex-wrap: nowrap; scrollbar-width: none; background-color: var(--color-bg); border-radius: 12px; padding: 0.3rem; gap: 5px; }
        .tabs::-webkit-scrollbar { display: none; }
        
        .tab-button { padding: 0.6rem 1.1rem; border: none; background-color: transparent; cursor: grab; font-size: 0.9rem; font-weight: 500; color: var(--color-text-secondary); transition: all 0.3s ease; white-space: nowrap; border-radius: 10px; flex-grow: 1; text-align: center; }
        .tab-button:active { cursor: grabbing; }
        .tab-button.active { color: var(--color-primary); background-color: var(--color-surface); box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .tab-button.dragging { opacity: 0.5; }
        
        .tab-contents-container { flex-grow: 1; position: relative; overflow: hidden; transition: all 0.4s ease-in-out; }
        
        .tab-content {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .tab-content.active { visibility: visible; opacity: 1; }
        .tab-content iframe { width: 100%; height: 100%; border: none; border-radius: 12px; }

        /* PESTAÑA PDF */
        #pdf-content { flex-direction: column; gap: 1rem; height: 100% }
        
        .options-pill-container {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding-bottom: 5px;
            scrollbar-width: none;
            cursor: grab;
            user-select: none;
        }
        .options-pill-container.grabbing { cursor: grabbing; }
        .options-pill-container::-webkit-scrollbar { display: none; }
        
        .options-pill-btn {
            background-color: white;
            color: var(--color-text-secondary);
            border: 1px solid var(--color-border);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        .options-pill-btn:hover { background-color: #e5e7ed; }
        .options-pill-btn.active {
            background-color: var(--color-primary);
            color: white;
            border-color: var(--color-primary);
            box-shadow: 0 2px 8px rgba(138, 77, 255, 0.2);
        }

        .pdf-floating-button { position: absolute; top: 1rem; right: 1rem; z-index: 10; padding: 0.8rem 1rem; background-color: var(--color-primary); color: white; border-radius: 50px; text-decoration: none; box-shadow: 0 4px 12px rgba(0,0,0,0.2); transition: all 0.3s ease; display: flex; align-items: center; gap: 0.5rem; font-weight: 600; font-size: 0.9rem; }
        .pdf-iframe-container { flex-grow: 1; border-radius: 12px; overflow: hidden; position: relative; }
        .pdf-iframe-container iframe { width: 100%; height: 100%; border: none; }

        /* PESTAÑA PLUS */
        #plus-content { flex-direction: column; gap: 1rem; height: 100% }
        .plus-iframe-container { flex-grow: 1; border-radius: 12px; overflow: hidden; }
        
        .plus-options-slider-container { position: relative; flex-shrink: 0; }
        .plus-options-arrow { position: absolute; top: 50%; transform: translateY(-50%); z-index: 2; background-color: var(--color-surface); border: 1px solid var(--color-border); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; display: none; place-items: center; box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.3s, transform 0.3s; }
        .plus-options-arrow:hover { background-color: var(--color-bg); transform: translateY(-50%) scale(1.1); }
        #plus-slide-left-btn { left: 2px; }
        #plus-slide-right-btn { right: 2px; }

        .plus-options { display: flex; gap: 0.75rem; flex-wrap: nowrap; overflow-x: auto; scroll-behavior: smooth; user-select: none; cursor: grab; scrollbar-width: none; }
        .plus-options.grabbing { cursor: grabbing; }
        .plus-options::-webkit-scrollbar { display: none; }

        /* --- NOTAS (ACORDEÓN) --- */
        .notes-container { display: flex; flex-direction: column; flex-grow: 1; height: 100%;}
        #notes-list-accordion { 
            flex-grow: 1; 
            overflow-y: auto; 
            display: flex; 
            flex-direction: column; 
            gap: 0.5rem; 
            padding-right: 0.5rem; 
            min-height: 150px; 
        }
        .note-accordion-item { background-color: var(--color-bg); border-radius: 10px; }
        .note-accordion-header { padding: 0.9rem 1rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .note-accordion-header span { font-weight: 600; font-size: 0.9rem; color: var(--color-text-primary); }
        .note-accordion-header i { color: var(--color-primary); transition: transform 0.3s ease; }
        .note-accordion-item.open .note-accordion-header i { transform: rotate(180deg); }
        .note-accordion-content { display: grid;
    grid-template-rows: 0fr; /* Estado cerrado */
    transition: grid-template-rows 0.2s ease-out; /* Animación rápida y fluida */
    padding: 0 1rem; /* Padding horizontal fijo */
    overflow: hidden; /* Necesario para grid animation */}
        .note-accordion-item.open .note-accordion-content { grid-template-rows: 1fr; /* Estado abierto */
    padding-bottom: 1rem; /* Solo agregamos padding abajo al abrir */}
        .notes-list-inner { min-height: 0; /* Necesario para que funcione la animación grid */
    overflow: hidden; 
    display: flex; 
    flex-direction: column; 
    gap: 0.75rem; 
    border-top: 1px solid var(--color-border); 
    padding-top: 1rem;}
        .note-item { padding: 1rem; background-color: var(--color-surface); border-radius: 10px; display: flex; justify-content: space-between; align-items: flex-start; flex-shrink: 0; gap: 0.5rem; }

        .note-content-display { flex-grow: 1; word-break: break-word; }
        .note-header { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; }
        .note-content-display .timestamp { font-weight: 600; color: var(--color-primary); cursor: pointer; font-size: 0.9rem; }
        .note-title { font-weight: 600; color: var(--color-text-primary); font-size: 0.9rem; }
        .note-text-display { margin-top: 0.5rem; color: var(--color-text-secondary); font-size: 0.9rem; line-height: 1.6; }

        .note-item-actions-display { display: flex; flex-shrink: 0; gap: 0.25rem; }
        .edit-note-btn, .delete-note-btn { background: none; border: none; color: var(--color-text-secondary); cursor: pointer; font-size: 1rem; width: 30px; height: 30px; border-radius: 50%; display: grid; place-items: center; }
        .edit-note-btn:hover { color: var(--color-primary); background-color: var(--color-primary-light); }
        .delete-note-btn:hover { color: var(--color-error); background-color: var(--color-error-light); }
        
        .note-content-edit, .note-item-actions-edit { display: none; }
        .note-item.is-editing .note-content-display, .note-item.is-editing .note-item-actions-display { display: none; }
        .note-item.is-editing { flex-direction: column; gap: 0.75rem; }
        .note-item.is-editing .note-content-edit { display: flex; flex-direction: column; gap: 0.5rem; width: 100%; }
        .note-item.is-editing .note-content-edit .note-edit-grid { display: grid; grid-template-columns: 90px 1fr; gap: 0.5rem; width: 100%; padding-bottom: 10px; }
        .note-item.is-editing .note-text-input { margin-top: 0.5rem; }
        .note-item.is-editing .note-item-actions-edit { display: flex; gap: 0.5rem; width: 100%; }
        
        .note-title-input, .note-text-input, .note-time-input { width: 100%; padding: 0.7rem; border: 1px solid var(--color-border); border-radius: 8px; font-size: 0.9rem; font-family: 'Poppins', sans-serif; }
        .note-text-input { resize: vertical; min-height: 80px; }
        .save-note-btn, .cancel-edit-btn { padding: 0.6rem 1rem; font-size: 0.85rem; }
        
        .notes-footer { flex-shrink: 0; padding-top: 1rem; display: flex; flex-direction: column; gap: 1rem; background: white; z-index: 50;}
        .note-inputs-grid { display: grid; grid-template-columns: 1fr 0.85fr; gap: 0.75rem; }
        #note-input-title, #note-input-time { width: 100%; padding: 0.8rem; border: 1px solid var(--color-border); border-radius: 8px; font-size: 0.9rem; font-family: 'Poppins', sans-serif; line-height: 1.2; }
        #note-input { width: 100%; padding: 0.8rem; border: 1px solid var(--color-border); border-radius: 8px; resize: vertical; min-height: 60px; font-size: 0.9rem;}
        .notes-actions { display: flex;
    gap: 0.5rem;
    align-items: center;
    justify-content: flex-end; /* Alineados a la derecha */}
      .icon-action-btn {
    background-color: var(--color-surface);
    border: 1px solid var(--color-border);
    color: var(--color-text-secondary);
    width: 40px;
    height: 40px;
    border-radius: 8px;
    display: grid;
    place-items: center;
    cursor: pointer;
    font-size: 1.1rem;
    transition: all 0.2s ease;
}
      .icon-action-btn:hover {
    background-color: var(--color-primary-light);
    color: var(--color-primary);
    border-color: var(--color-primary);
    transform: translateY(-2px);
}
      /* Botón principal (Añadir nota) se mantiene grande */
#add-note-btn {
    flex-grow: 1; /* Ocupa el espacio restante */
}
      .import-modal-body {
    padding: 1.5rem;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    background-color: #f9fafb;
}
      .import-video-group {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 8px;

}
      .import-video-header {
    padding: 0.8rem 1rem;
    background: #edf2f7;
    font-weight: 600;
    font-size: 0.9rem;
    border-bottom: 1px solid var(--color-border);
    color: var(--color-text-primary);
}

.import-note-item {
    padding: 0; /* Quitamos padding del contenedor padre */
    border-bottom: 1px solid var(--color-border);
    transition: all 0.2s ease;
    width: 100%; /* Asegurar ancho completo */
    display: block; /* IMPORTANTE: No usar grid aquí */
}

.import-note-item:last-child { border-bottom: none; }

.import-note-content small {
    display: flex; /* Para alinear badges */
    align-items: center;
    flex-wrap: wrap;
    color: var(--color-primary);
    font-weight: 600;
    font-size: 0.8rem;
    margin-bottom: 0.3rem;
}

.import-note-content p {
    font-size: 0.9rem;
    color: var(--color-text-secondary);
    line-height: 1.5;
}

.import-note-content strong { color: var(--color-text-primary); }

/* Etiquetas para identificar origen */
.badge-new { 
    background: #e6fffa; 
    color: #047481; 
    border: 1px solid #b2f5ea; 
}

.badge-exist { 
    background: #fff5f5; 
    color: #c53030; 
    border: 1px solid #fed7d7; 
}

.import-delete-btn {
    color: var(--color-error);
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1rem;
    padding: 5px;
}
.import-delete-btn:hover { background-color: var(--color-error-light); border-radius: 4px; }
        .interactive-header { display: none; }

        /* --- MODAL PARA REORDENAR TABS --- */
        .reorder-modal-backdrop { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center; padding: 1rem; }
        .reorder-modal-backdrop.visible { display: flex; }
        .reorder-modal { background: var(--color-surface); padding: 1.5rem; border-radius: var(--border-radius); width: 100%; max-width: 400px; display: flex; flex-direction: column; gap: 1rem; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        .reorder-modal h3 { margin-bottom: 0.5rem; }
        .reorder-list { display: flex; flex-direction: column; gap: 0.5rem; max-height: 60vh; overflow-y: auto; padding-right: 0.5rem; }
        .reorder-item { display: flex; justify-content: space-between; align-items: center; background: var(--color-bg); padding: 0.75rem 1rem; border-radius: 8px; }
        .reorder-item span { font-weight: 500; font-size: 0.9rem; }
        .reorder-item-controls { display: flex; gap: 0.5rem; }
        .reorder-item-controls button { background: var(--color-surface); border: 1px solid var(--color-border); width: 30px; height: 30px; border-radius: 50%; cursor: pointer; display: grid; place-items: center; color: var(--color-text-primary); }
        .reorder-item-controls button:disabled { opacity: 0.3; cursor: not-allowed; background: var(--color-bg); }
        #close-reorder-modal { width: 100%; }

        /* --- RESPONSIVE DESIGN --- */
        @media (min-width: 1101px) and (max-width: 1450px) { .main-container { grid-template-columns: 63% 35%; gap: 2%; } }
       
      
 /* ================================================================= */
/* ===  LAYOUT TABLET/LAPTOP PEQUEÑA (900px - 1099px) - FIXED TABS === */
/* ================================================================= */

@media (min-width: 780px) and (max-width: 1100px) {

    /* 1. CONFIGURACIÓN DEL CONTENEDOR PRINCIPAL (Sin Scroll General) */
    .app-content {
        overflow: hidden !important; /* Desactiva scroll de la ventana entera */
    }

    .main-container {
        display: grid;
        grid-template-columns: 57% 41%;
        gap: 2%;
        padding: 1rem 1rem 0 1rem; /* Padding solo arriba y lados */
        width: 100%;
        /* Altura exacta: 100vh menos el header (65px) menos padding */
        height: calc(100vh - 65px); 
        overflow: hidden; /* Asegura que el contenedor no crezca */
    }

    /* 2. COLUMNA IZQUIERDA (Scroll Independiente) */
    .left-column {
        height: 100%;
        overflow-y: auto; /* Scroll vertical activado */
        padding-right: 8px; /* Espacio para la barra de scroll */
        padding-bottom: 1rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .video-section.card {
        margin: 0; /* Reset de margenes negativos móviles si los hubiera */
        border-radius: var(--border-radius);
    }

    /* 3. COLUMNA DERECHA (Contenedor Flex para Sticky Tabs) */
    .right-column {
        position: static; /* Quitamos sticky global */
        height: 100%;
        overflow: hidden; /* El contenedor no scrollea, sus hijos sí */
        padding-bottom: 1rem;
    }



    /* --- CUERPO (Contenido) CON SCROLL --- */
    .tab-contents-container {
        flex-grow: 1; /* Ocupa todo el espacio restante */
        overflow-y: auto; /* AQUÍ está el scroll general de la derecha */
        padding: 0; /* Padding se maneja en los hijos o globalmente aquí */
        background-color: #fafafa; /* Fondo suave para el área de contenido */
        position: relative;
    }

    /* Ajuste crítico: Cambiar absolute por flujo normal para permitir scroll */
    .tab-content {
        position: relative; /* Ya no absolute */
        height: auto;
        min-height: 100%;
        display: none; /* Ocultar por defecto */
        visibility: visible;
        opacity: 1;
        padding: 1rem;
    }

    .tab-content.active {
        display: flex; /* Mostrar solo el activo */
    }

    /* --- AJUSTES ESPECÍFICOS POR PESTAÑA PARA ESTE MODO --- */

    /* PDF / Iframe Plus / Quiz */
    .pdf-iframe-container, 
    .plus-iframe-container,
    #quiz-content iframe,
    #ai-content iframe,
    #flashcards-content iframe {
       height: 600px; /*  Altura fija alta para que valga la pena el scroll */
        width: 100%;
        background: white;
        border-radius: 12px;
        
    }

  .pdf-iframe-container, .plus-iframe-container{
  height: 0px;
  }
  
  #quiz-content, #ai-content, #flashcards-content  {
  height: 100%;
  position: relative;
  overflow-y: visible;
  padding: 0px;
  }
  
  #quiz-content iframe, #ai-content iframe,
    #flashcards-content iframe {
  height: 100%;
  min-height: 600px;
   }
  
    /* Notas (Acordeón) */
    #notes-content {
        padding: 0; /* Las notas usan su propio layout */
        background: white;
        height: 100%;
    }
    
    .notes-container {
        height: auto; /* Dejar crecer naturalmente */
        min-height: 100%;
        display: flex;
        flex-direction: column;
    }

    /* El acordeón ya no necesita scroll propio, usa el del padre (.tab-contents-container) */
    #notes-list-accordion {
        flex-grow: 0; 
        overflow: auto; 
        height: 100%;
        padding: 1rem;
    }

    .notes-footer {
        position: sticky; /* Footer de notas pegajoso abajo si se desea */
        bottom: 0;
        background: var(--color-surface);
        border-top: 1px solid var(--color-border);
        z-index: 5;

    }   
}     
  
      
      
      
      
      
   @media (max-height: 700px) and (min-width: 899px) {
        .notes-footer {
        position: sticky; /* Footer de notas pegajoso abajo si se desea */
        bottom: 0;
        background: var(--color-surface);
        border-top: 1px solid var(--color-border);
        padding: 1rem;
        z-index: 5;
        max-height: 150px;
        overflow-x: auto; }  
     
 }      
          
        @media (max-width: 779px) {  
            .main-container { grid-template-columns: 1fr; height: auto; padding: 0 1rem 1rem 1rem; display: flex; flex-direction: column; gap: 1rem; } 
            .left-column { display: contents; }
            .video-section { order: 1; }
            .right-column { order: 2; }
            .info-section { order: 3; }
            .comments-section { order: 4; }
            .video-section.card { margin: 1rem -1rem; border-radius: 0; position: sticky; top: 55px; z-index: 90; background-color: white; }
            .video-player-container { border-radius: 0; }
            .right-column { position: static; height: auto; }
            .interactive-section.card { padding: 1.5rem; min-height: 0; }
            .interactive-section.card:not(.collapsed) { min-height: 800px; }
            .interactive-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; margin: -1.5rem -1.5rem 0; padding: 1.5rem; padding-bottom: 1.5rem; }
            .interactive-header h3 { font-size: 1.1rem; }
            #toggle-interactive-btn { background: none; border: none; font-size: 1.2rem; transition: transform 0.3s ease; }
            .interactive-section.card.collapsed #toggle-interactive-btn { transform: rotate(-90deg); }
            .interactive-section.card.collapsed .tabs-slider-container,
            .interactive-section.card.collapsed .tab-contents-container { visibility: hidden; max-height: 0; overflow: hidden; margin-bottom: 0; transition: max-height 0.4s ease-in-out; }
            .notes-actions { flex-wrap: wrap; gap: 0.75rem; }
            .notes-actions .button { flex-grow: 1; padding: 0.7rem 1rem; font-size: 0.85rem; }
            
            .timeline-item { width: 140px; }
            .timeline-thumbnail { height: 80px; }
            .timeline-arrow, .plus-options-arrow { display: none !important; }
            
            .tabs-slider-container.is-scrollable #reorder-tabs-btn { display: grid; }
        }
        
        @media (max-width: 768px) { 

            .info-section.card h1 { font-size: 1.3rem; } 
            .channel-info { flex-direction: column; align-items: flex-start; } 
        }

        @media (max-width: 480px) {
            .channel-actions .button-secondary span,
            .channel-actions .custom-subscribe-btn span { display: none; }
            .channel-actions .button-secondary,
            .channel-actions .custom-subscribe-btn { padding: 0; width: 40px; height: 40px; border-radius: 50%; gap: 0; }
            
            .note-inputs-grid { gap: 0.5rem; }
            .note-item.is-editing .note-content-edit .note-edit-grid { grid-template-columns: 0.8fr 1fr; }
        }
      
        i.fi.fi-rr-brain-circuit { padding-right: 5px; color: var(--color-primary); } 
        i.fa-solid.fa-chevron-down { color: var(--color-primary); }
        i.fa-solid.fa-bookmark { color: var(--color-primary); }
        
        /* --- TOOLTIP --- */
        #global-tooltip {
            position: fixed;
            background-color: #2d3142;
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            line-height: 1.4;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: translateY(5px);
            max-width: 250px;
            text-align: center;
        }

        #global-tooltip.visible { opacity: 1; visibility: visible; transform: translateY(0); }
        #global-tooltip b { color: var(--color-primary-light); }
      
      
      /* 1. Regla para el modo HOVER (Solo PC > 1400px) */
        @media (min-width: 1401px) {
            body.sidebar-hover-active #sidebar-overlay {
                opacity: 1;
                visibility: visible;
                pointer-events: auto;
            }
        }

        /* 2. Regla para activación MANUAL (Tablet y Móvil) */
        body.overlay-active #sidebar-overlay {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
      
      
 /* --- RESPONSIVE DEL MODAL (CELULAR) --- */

/* 1. Área de subida (Upload Area) */
@media (max-width: 600px) {
    .modal-upload-area {
        padding: 1rem;
    }
    
    .upload-controls {
        flex-direction: column;
        align-items: stretch; /* Ocupar todo el ancho */
        gap: 1rem;
    }
    
    .upload-controls > div {
        text-align: center;
    }
    
    #trigger-file-select {
        width: 100%;
        justify-content: center;
        padding: 0.8rem;
    }
.notes-footer {
    padding-top: 1rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
    overflow-x: auto;
    position: sticky;   
    }
 #editor-container{ height: 90px;}
  
 }
/* 2. Footer del Modal (Footer Mobile) */
.footer-text-group {
    margin-right: auto;
    display: flex;
    gap: 1rem;
    align-items: center;
}
      

     

@media (max-width: 500px) {
    .filter-modal-footer {
        padding: 1rem;
        display: flex;
        justify-content: space-between; /* Texto izquierda, Botón derecha */
        align-items: center;
    }

    /* Agrupar textos uno debajo del otro */
    .footer-text-group {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.2rem;
        margin-right: 0.5rem;
    }

  
  
  
    /* Ajustes visuales de los textos */
    .footer-text-group label { font-size: 0.85rem !important; }
    #import-summary-text { font-size: 0.75rem !important; margin: 0 !important; }

    /* Botón Guardar: Solo icono en móvil */
    #save-import-btn span { display: none; }
    #save-import-btn {
        padding: 0;
        width: 45px;
        height: 45px;
        border-radius: 50%; /* Redondo */
        display: grid;
        place-items: center;
        flex-shrink: 0;
        font-size: 1.2rem;
    }
    #save-import-btn i { margin: 0; display: block !important; }
}     
      
      
      
      
      
      
      
      
      
  .area52 { 
   display: flex;
  flex-direction: column;
    overflow-x: hidden;
      }       
      
  @media (max-height: 900px)  {   
      .area52 {
           display: block;
    overflow-x: auto;}   
  
 }        
      
@media (max-width: 400px) {
    .interactive-section.card:not(.collapsed) {
        min-height: 1000px;
    }
}      
      
      
      
      
      
      
      
      
    </style>
</head>
<body class="sidebar-collapsed security-check-pending">
    
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/es_LA/sdk.js#xfbml=1&version=v20.0&appId=TU_APP_ID_DE_FACEBOOK" nonce="a1b2c3d4"></script>

    <div id="sidebar-overlay"></div>

    <div id="app-layout">
        <aside class="app-sidebar collapsed">
            <div class="sidebar-header">
                <a href="#" class="sidebar-logo">
                    <img src="https://acamedic130.github.io/audios/ACAMEDIC%20LOGO.png" alt="Logo">
                    <span class="logo-text">AcaMedic</span>
                </a>
                <button id="sidebar-close-btn" aria-label="Cerrar barra lateral">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <div class="sidebar-filters">
                <div class="search-bar-container">
                    <i class="fa-solid fa-search"></i>
                    <input type="text" id="search-subtopics" placeholder="Buscar subtema...">
                </div>
                <button id="filter-btn" aria-label="Abrir filtros">
                    <i class="fa-solid fa-filter"></i>
                </button>
            </div>
            <nav class="sidebar-topic-list" id="sidebar-topic-list">
                </nav>
            
            <div class="sidebar-footer">
                <button id="sidebar-toggle-btn" aria-label="Colapsar barra lateral">
                    <i class="fa-solid fa-chevron-left"></i>
                    <span class="toggle-text">Colapsar</span>
                </button>
            </div>
        </aside>
        
        <div class="app-content">
            
            <header class="app-header-mobile">
                <button id="mobile-menu-btn" aria-label="Abrir menú">
                    <i class="fi fi-rs-align-left"></i>
                </button>
                <a href="#" class="sidebar-logo">
                    <img src="https://acamedic130.github.io/audios/ACAMEDIC%20LOGO.png" alt="Logo">
                    <span class="logo-text">AcaMedic</span>
                </a>
            </header>
            
            <main class="main-container">
                <div class="left-column">
                    <section class="video-section card">
                        <div class="video-player-container">
                            <div id="youtube-player"></div>
                        </div>
                    </section>
                    
                    <section class="info-section card">
                        <h1 id="video-title">Cargando título...</h1>
                        <div class="video-meta">
                            <span id="video-duration"><i class="fa-regular fa-clock"></i> --:--</span> &bull; 
                            <span id="video-publish-date">Cargando fecha...</span>
                        </div>
                        
                        <div class="channel-info">
                            <div class="channel-details">
                                <img id="channel-icon" src="https://acamedic130.github.io/audios/ACAMEDIC%20LOGO.png" alt="Logo del Canal">
                                <div class="channel-name">
                                    <span id="channel-name">AcaMedic Group</span>
                                    <small id="subscriber-count">Cargando...</small>
                                </div>
                            </div>
                            <div class="channel-actions">
                                <button class="like-icon-button" id="like-btn" aria-label="Me Gusta">
                                    <i class="fi fi-rr-social-network"></i>
                                </button>
                                <a href="#" id="comment-yt-btn" target="_blank" class="button button-secondary">
                                    <i class="fa-regular fa-comment"></i> <span>Comentar</span>
                                </a>
                                <a href="https://www.youtube.com/channel/UCt5Fk3CCYh03Oaxu8eXCo_w?sub_confirmation=1" target="_blank" class="custom-subscribe-btn">
                                    <i class="fab fa-youtube"></i> <span>Suscribirse</span>
                                </a>
                            </div>
                        </div>

                        <div class="description-content">
                          <p id="video-description">Cargando descripción...</p>
                          
                          <div class="video-timeline-carousel">
                              <h3><i class="fa-solid fa-bookmark"></i> Línea de Tiempo del Video</h3>
                              <div class="timeline-slider-container">
                                  <button id="timeline-slide-left-btn" class="slider-arrow timeline-arrow" aria-label="Desplazar a la izquierda"><i class="fa-solid fa-chevron-left"></i></button>
                                  <div id="timeline-items-wrapper" class="timeline-items-wrapper">
                                      </div>
                                  <button id="timeline-slide-right-btn" class="slider-arrow timeline-arrow" aria-label="Desplazar a la derecha"><i class="fa-solid fa-chevron-right"></i></button>
                              </div>
                          </div>
                      </div>
                    </section>

                    <section class="comments-section card">
                        <h2><i class="fa-brands fa-facebook"></i> Conversación</h2>
                        <p class="comments-motivation-message">
                            ¡Anímate a participar! <strong>Deja tus dudas, preguntas o comparte tus conocimientos</strong> con la comunidad. Juntos aprendemos más.
                        </p>
                        <div class="fb-comments-container">
                            </div>
                    </section>
                </div>

                <div class="right-column">
                    <aside class="interactive-section card">
                        <div class="interactive-header">
                            <h3><i class="fi fi-rr-brain-circuit"></i> Herramienta Interactiva</h3>
                            <button id="toggle-interactive-btn" aria-label="Contraer o expandir panel"><i class="fa-solid fa-chevron-down"></i></button>
                        </div>

                        <div class="tabs-slider-container">
                            <button id="slide-left-btn" class="slider-arrow" aria-label="Desplazar a la izquierda"><i class="fa-solid fa-chevron-left"></i></button>
                            <nav class="tabs" id="tabs-container">

                            </nav>
                            <button id="slide-right-btn" class="slider-arrow" aria-label="Desplazar a la derecha"><i class="fa-solid fa-chevron-right"></i></button>
                            <button id="reorder-tabs-btn" aria-label="Reordenar pestañas"><i class="fa-solid fa-arrows-up-down"></i></button>
                        </div>
                        
                        <div class="tab-contents-container">

<div id="pdf-content" class="tab-content">
    <div class="plus-options-slider-container"> <button id="pdf-slide-left-btn" class="plus-options-arrow" aria-label="Desplazar izquierda">
            <i class="fa-solid fa-chevron-left"></i>
        </button>
        
        <div class="pdf-options options-pill-container plus-options"> 
        </div>
        
        <button id="pdf-slide-right-btn" class="plus-options-arrow" aria-label="Desplazar derecha">
            <i class="fa-solid fa-chevron-right"></i>
        </button>
    </div>

    <div class="pdf-iframe-container">
        <a href="" target="_blank" class="pdf-floating-button" style="display: none;">
            <i class="fa-solid fa-arrow-up-right-from-square"></i> Abrir
        </a>
        </div>
</div>
                            
                            <div id="quiz-content" class="tab-content">
                                <iframe src=""></iframe>
                            </div>
                            
                            <div id="notes-content" class="tab-content">
                             <div class="notes-container">
                                  <div class="notes-search-wrapper">
                                      <div class="notes-search-input-container">
                                          <i class="fa-solid fa-magnifying-glass"></i>
                                          <input type="text" id="notes-smart-search" placeholder="Buscar en tus apuntes (inteligente)...">
                                      </div>
                                  </div>

                                  <div id="notes-list-accordion"></div>

                                  <div class="notes-footer">
                                      <p style="font-size: 0.8rem; color: var(--color-text-secondary); text-align: center; margin-bottom: -0.5rem;">
                                          Añadiendo nota a: <strong id="current-video-note-title">...</strong>
                                      </p>
                                      <div class="note-inputs-grid">
                                          <input type="text" id="note-input-title" placeholder="Título (opcional)...">
                                          <input type="text" id="note-input-time" placeholder="Tiempo (ej: 1:30)">
                                      </div>
                                      <div id="editor-wrapper">
                                          <div id="editor-container"></div>
                                      </div>
                                      <input type="hidden" id="note-input">

                                      <div class="notes-actions">
                                          <button id="add-note-btn" class="button button-primary">Añadir Nota</button>
                                          <button id="upload-notes-btn" class="icon-action-btn" title="Subir e Importar Notas">
                                              <i class="fa-solid fa-cloud-arrow-up"></i>
                                          </button>
                                          <button id="download-notes-btn" class="icon-action-btn" title="Descargar Notas">
                                              <i class="fa-solid fa-cloud-arrow-down"></i>
                                          </button>
                                      </div>
                                  </div>
                              </div>
                            </div>
                            <div id="ai-content" class="tab-content">
                                <iframe src=""></iframe>
                            </div>

                            <div id="flashcards-content" class="tab-content">
                                <iframe src=""></iframe>
                            </div>

                            <div id="plus-content" class="tab-content">
                                <div class="plus-options-slider-container">
                                    <button id="plus-slide-left-btn" class="plus-options-arrow" aria-label="Desplazar a la izquierda"><i class="fa-solid fa-chevron-left"></i></button>
                                    <div class="plus-options options-pill-container"> 
                                      
                                    </div>
                                    <button id="plus-slide-right-btn" class="plus-options-arrow" aria-label="Desplazar a la derecha"><i class="fa-solid fa-chevron-right"></i></button>
                                </div>
                                <div class="plus-iframe-container">
                                    </div>
                            </div>
                        </div>
                    </aside>
                </div>
            </main>
        </div>
    </div>

    <div id="filter-modal-backdrop" class="filter-modal-backdrop">
        <div id="filter-modal" class="filter-modal">
            <div class="filter-modal-header">
                <h3>Filtrar Contenido</h3>
                <button id="close-filter-modal-btn" class="button button-secondary" style="padding: 0.5rem; min-width: 36px; height: 36px;">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <div class="filter-modal-body">
                <div class="filter-group">
                    <h4>Estado</h4>
                    <div class="filter-options" id="filter-group-status">
                        <label><input type="radio" name="filter-status" value="all" checked> <span>Todos</span></label>
                        <label><input type="radio" name="filter-status" value="completed"> <span>Completados</span></label>
                        <label><input type="radio" name="filter-status" value="pending"> <span>Pendientes</span></label>
                    </div>
                </div>
                <div class="filter-group">
                    <h4>Prioridad</h4>
                    <div class="filter-options" id="filter-group-priority">
                        <label><input type="radio" name="filter-priority" value="all" checked> <span>Todas</span></label>
                        <label><input type="radio" name="filter-priority" value="high"> <span style="color: var(--color-success)">Alta</span></label>
                        <label><input type="radio" name="filter-priority" value="medium"> <span style="color: var(--color-warning)">Media</span></label>
                        <label><input type="radio" name="filter-priority" value="low"> <span style="color: var(--color-error)">Baja</span></label>
                        <label><input type="radio" name="filter-priority" value="low-medium"> <span style="color: var(--color-low-medium)">Plomo</span></label>
                    </div>
                </div>
                <div class="filter-group">
                    <h4>Subtemas</h4>
                    <div id="filter-subtopics-list">
                        </div>
                </div>
            </div>
            <div class="filter-modal-footer">
                <button id="reset-filters-btn" class="button button-secondary">Limpiar Filtros</button>
                <button id="apply-filters-btn" class="button button-primary">Aplicar</button>
            </div>
        </div>
    </div>
    <div id="reorder-modal-backdrop" class="reorder-modal-backdrop">
        <div id="reorder-modal" class="reorder-modal">
            <h3>Reordenar Pestañas</h3>
            <div id="reorder-list" class="reorder-list">
                </div>
            <button id="close-reorder-modal" class="button button-primary">Hecho</button>
        </div>
    </div>
 
  
  
  

  

<div id="import-modal-backdrop" class="filter-modal-backdrop">
    <div class="filter-modal" style="max-width: 800px; max-height: 90vh;">
        <div class="filter-modal-header">
            <h3><i class="fa-solid fa-list-check"></i> Gestión de Notas</h3>
            <button id="close-import-modal" class="button button-secondary" style="padding: 0.5rem; width: 36px; height: 36px;">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
<div class="area52">       
        <div class="modal-upload-area">
            <div class="upload-controls">
                <div>
                    <h4 style="font-size: 0.9rem; margin-bottom: 0.2rem;">Importar Archivos</h4>
                    <p style="font-size: 0.8rem; color: var(--color-text-secondary);">Selecciona archivos .json y .txt</p>
                </div>
                <input type="file" id="modal-file-input" accept=".txt, .json" multiple style="display: none;">
                <button id="trigger-file-select" class="button button-secondary">
                    <i class="fa-solid fa-cloud-arrow-up"></i> Seleccionar Archivos
                </button>
            </div>
            
            <div class="file-slider-wrapper">
                <button id="file-arrow-left" class="file-arrow"><i class="fa-solid fa-chevron-left"></i></button>
                <div id="file-list-display" class="file-list-display"></div>
                <button id="file-arrow-right" class="file-arrow"><i class="fa-solid fa-chevron-right"></i></button>
            </div>

            <div style="margin-top: 1rem; border-top: 1px solid var(--color-border); padding-top: 1rem;">
                <div class="search-bar-container" style="background: white; border: 1px solid var(--color-border); border-radius: 8px;">
                    <i class="fa-solid fa-search" style="color: var(--color-primary);"></i>
                    <input type="text" id="import-search-input" placeholder="Buscar en tus notas (título, contenido, video)..." 
                        style="width: 100%; border: none; outline: none; padding: 0.7rem 0.7rem 0.7rem 2.5rem; font-size: 0.9rem; background: transparent;">
                </div>
            </div>
        </div>

        <div class="filter-modal-body" style="padding: 0; background: #f9fafb;">
            <div id="import-list-container" class="import-modal-body"></div>
        </div>
</div>
        <div class="filter-modal-footer">
            <div class="footer-text-group">
                <label style="display: flex; align-items: center; gap: 5px; font-size: 0.85rem; cursor: pointer;">
                    <input type="checkbox" id="select-all-import" checked> Seleccionar todo
                </label>
                <span id="import-summary-text" style="font-size: 0.85rem; color: var(--color-text-secondary);">Seleccionadas: 0</span>
            </div>
            
            <div style="display: flex; gap: 0.5rem;">
                <button id="download-all-import-btn" class="button button-secondary" title="Descargar todas las notas">
                    <i class="fa-solid fa-download"></i>
                </button>
                
                <button id="save-import-btn" class="button button-primary">
                    <i class="fa-solid fa-floppy-disk"></i> <span>Guardar Cambios</span>
                </button>
            </div>
        </div>
    </div> 
</div>
  
  
  
 
  
  
  
  
  
  
  
  
<div id="quick-view-backdrop" class="filter-modal-backdrop" style="z-index: 2000;">
    <div class="filter-modal quick-view-modal" style="max-width: 95vw; height: 90vh; width: 1200px;">
        <div class="filter-modal-header">
            <h3 id="quick-view-title" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 1rem;">
                <i class="fa-brands fa-youtube"></i> Revisión de Video
            </h3>
            <button id="close-quick-view" class="button button-secondary" style="padding: 0.5rem; min-width: 36px; height: 36px;">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="quick-view-body">
            <div class="quick-view-video">
                <div id="quick-player-container"></div>
            </div>
            <div class="quick-view-notes">
                <div class="notes-container">
                    <div id="quick-notes-list" class="quick-notes-list"></div>
                    
                    <div class="quick-notes-footer">
                        <p style="font-size: 0.8rem; color: var(--color-text-secondary); text-align: center; margin-bottom: -0.5rem;">
                            Añadiendo nota a este video externo
                        </p>
                        <div class="note-inputs-grid">
                            <input type="text" id="quick-note-title" class="note-title-input" placeholder="Título (opcional)...">
                            <input type="text" id="quick-note-time" class="note-time-input" placeholder="Tiempo (ej: 1:30)">
                        </div>
                        <textarea id="quick-note-text" class="note-text-input" placeholder="Escribe tu apunte aquí..." style="min-height: 60px;"></textarea>
                        
                        <div class="notes-actions">
                            <button id="quick-add-btn" class="button button-primary" style="flex-grow: 1;">Añadir Nota</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
  
  
  
  
<div id="download-loader" class="download-loader-overlay">
    <div class="loader-card">
        <div class="loader-icon">
            <i class="fa-solid fa-cloud-arrow-down"></i>
        </div>
        <h3 class="loader-title">Preparando tu archivo</h3>
        <p class="loader-subtitle" id="loader-message">Generando documento...</p>
        
        <div class="progress-track">
            <div class="progress-fill" id="loader-progress-bar"></div>
        </div>
        <div class="progress-text" id="loader-percent">0%</div>
    </div>
</div>  
  
  
  
  
  
      <div id="global-tooltip" class="global-tooltip"></div>
  
<script>
// =========================================================
// === 0. CAPA DE BASE DE DATOS PROFESIONAL (IndexedDB) ===
// =========================================================

const DB_CONFIG = {
    name: 'AcaMedicDB_Enterprise', // Nombre actualizado para asegurar estructura nueva
    version: 1,
    stores: {
        notes: 'videoId',      // Almacena array de notas por video
        titles: 'videoId',     // Caché de títulos de videos
        global: 'key',         // Configuraciones globales
        imported: 'ctxHash'    // Referencias de notas importadas por página
    }
};

const INTEGRITY_SALT = "AcaMedic_Secure_Salt_v2026_@#$!";

// Generador de Hash Simple
const generateHash = (data) => {
    const str = JSON.stringify(data) + INTEGRITY_SALT;
    let hash = 0;
    if (str.length === 0) return hash;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return hash.toString();
};

const db = {
    db: null,

    init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_CONFIG.name, DB_CONFIG.version);

            request.onupgradeneeded = (event) => {
                const database = event.target.result;
                if (!database.objectStoreNames.contains('notes')) database.createObjectStore('notes', { keyPath: 'videoId' });
                if (!database.objectStoreNames.contains('titles')) database.createObjectStore('titles', { keyPath: 'videoId' });
                if (!database.objectStoreNames.contains('global')) database.createObjectStore('global', { keyPath: 'key' });
                if (!database.objectStoreNames.contains('imported')) database.createObjectStore('imported', { keyPath: 'ctxHash' });
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve(this.db);
            };

            request.onerror = (event) => {
                console.error("Error IndexedDB:", event.target.error);
                reject(event.target.error);
            };
        });
    },

    async get(storeName, key, defaultValue = null) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);

            request.onsuccess = () => {
                const record = request.result;
                if (record === undefined) {
                    resolve(defaultValue);
                    return;
                }
                if (record && typeof record === 'object' && '_hash' in record && '_data' in record) {
                    const currentHash = generateHash(record._data);
                    if (currentHash !== record._hash) {
                        console.warn(`Integridad fallida en ${storeName}/${key}`);
                        resolve(defaultValue); 
                        return;
                    }
                    resolve(record._data);
                } else {
                    resolve(record); 
                }
            };
            request.onerror = () => reject(request.error);
        });
    },

    async set(storeName, keyData, value) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
            const secureRecord = {
                [this._getKeyPath(storeName)]: keyData,
                _data: value,
                _hash: generateHash(value),
                _timestamp: Date.now()
            };

            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(secureRecord);

            request.onsuccess = () => resolve(true);
            request.onerror = () => reject(request.error);
        });
    },

    async getAll(storeName) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = () => {
                const results = {};
                request.result.forEach(record => {
                    const key = record[this._getKeyPath(storeName)];
                    if (record._hash && generateHash(record._data) === record._hash) {
                        results[key] = record._data;
                    }
                });
                resolve(results);
            };
            request.onerror = () => reject(request.error);
        });
    },

    _getKeyPath(storeName) {
        if (storeName === 'notes') return 'videoId';
        if (storeName === 'titles') return 'videoId';
        if (storeName === 'global') return 'key';
        if (storeName === 'imported') return 'ctxHash';
        return 'id';
    }
};

// =========================================================
// === 1. CONFIGURACIÓN DE SEGURIDAD Y PERMISOS ===
// =========================================================

const ROLE_PERMISSIONS = {
    'free': {
        allowedSidebarGroups: ['VideoTeca 2'],
        allowedTabs: ['notes-content'],
        allowNoteButtons: false 
    },
    'basico': {
        allowedSidebarGroups: ['VideoTeca 2'],
        allowedTabs: ['notes-content'],
        allowNoteButtons: false
    },
    'premium': {
        allowedSidebarGroups: ['Guía Fase 2', 'VideoTeca 2', 'VideoClase 2'],
        allowedTabs: ['pdf-content', 'quiz-content', 'notes-content', 'plus-content'],
        allowNoteButtons: true 
    },
    'premium a+': {
        allowedSidebarGroups: ['Guía Fase 2', 'VideoTeca 2', 'VideoClase 2'], 
        allowedTabs: ['pdf-content', 'quiz-content', 'notes-content', 'ai-content', 'flashcards-content', 'plus-content'], 
        allowNoteButtons: true
    }
};

let currentUserStatus = null; 
let userPermissions = null;
let currentGlobalAllowedIDs = new Set(); 

// =========================================================
// === 2. DATOS DEL CURSO ===
// =========================================================

        // =========================================================
        // === 2. DATOS DEL CURSO ===
        // =========================================================
        
        const sidebarStructure = [
            {
                topic: "Guía Fase 2",
                subtopics: [
                    { id: 'D5xB4reISfI', title: 'Cirugía pediátrica', priority: 'low-medium' }
                ]
            },
            {
                topic: "VideoTeca 2",
                subtopics: [
                    { id: 'e86T7opNUgA', title: 'Cirugía pediátrica', priority: 'low-medium' }
                ]
            },
            {
                topic: "VideoClase 2",
                subtopics: [
                    { id: 'G5_CODrdKOU', title: 'Atresia de esófago', priority: 'medium' },
                    { id: 'Ol-YTi-vMWQ', title: 'Atresias intestinales - atresia intestinal', priority: 'high' },
                    { id: 'dgk-I0XH60w', title: 'Enterocolitis necrotizante', priority: 'high' },
                    { id: 'zXNj5KBWlBw', title: 'Estenosis hipertrófica de píloro', priority: 'high' },
                    { id: '0WXQV1HQwXw', title: 'Invaginación intestinal - intusucepción intestinal', priority: 'high' },
                    { id: 'T5PPjhXRpog', title: 'Malformaciones del diafragma - hernia diafragmática', priority: 'high' }
                ]
            }
        ];

        const fullCourseData = {
            'D5xB4reISfI': {
                title: 'Esquema de Repaso: Cirugía Pediátrica',
                publishDate: 'Publicado hace 1 semana',
                description: 'Revisión completa de los conceptos clave en cirugía pediátrica.',
                timeline: [
                    { time: 10, title: 'Introducción' },
                    { time: 60, title: 'Atresia Esofágica' },
                    { time: 180, title: 'Hérnia Diafragmática' }
                ],
                resources: {
                    pdfEsquema: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview',
                    pdfMapas: 'https://drive.google.com/file/d/1DmDDymELofb-7zwvyqq-koWK-TLKzDU9/preview',
                    pdfMapas1: '',
                    pdfMapas2: '',
                    quizUrl: '',
                    aiUrl: '',
                    flashcardsUrl: '',
                    plus: {
                        cronograma: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview',
                        estadistica: 'https://drive.google.com/file/d/1nGApGTnmS7rEuUIDdS18NJ9yya8LszqW/preview',
                        videoclase: 'https://drive.google.com/file/d/1CCJJJuCR8mAVlowPt6fTVhb_8BzX4B27/preview',
                        videoteca: ''
                    }
                }
            },
            'e86T7opNUgA': { 
                title: 'Guía de Banqueo: Cirugía Pediátrica', 
                publishDate: 'Hace 2 semanas', 
                description: 'Preguntas frecuentes y banqueo de cirugía pediátrica.', 
                timeline: [], 
                resources: {
                    pdfEsquema: 'https://drive.google.com/file/d/1nGApGTnmS7rEuUIDdS18NJ9yya8LszqW/preview',
                    pdfMapas: 'https://drive.google.com/file/d/1DmDDymELofb-7zwvyqq-koWK-TLKzDU9/preview',
                    pdfMapas1: '',
                    pdfMapas2: '',
                    quizUrl: '',
                    aiUrl: '',
                    flashcardsUrl: '',
                    plus: {
                        cronograma: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview',
                        estadistica: 'https://drive.google.com/file/d/1nGApGTnmS7rEuUIDdS18NJ9yya8LszqW/preview',
                        videoclase: 'https://drive.google.com/file/d/1CCJJJuCR8mAVlowPt6fTVhb_8BzX4B27/preview',
                        videoteca: ''
                    }
                }
            },
            'G5_CODrdKOU': { 
                title: 'Mapa Conceptual: Atresia de esófago', 
                publishDate: 'Hace 3 días', 
                description: 'Explicación visual de la atresia de esófago.', 
                timeline: [{time: 5, title: 'Inicio'}, {time: 30, title: 'Clasificación'}], 
                resources: {
                    pdfEsquema: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview',
                    pdfMapas: 'https://drive.google.com/file/d/1DmDDymELofb-7zwvyqq-koWK-TLKzDU9/preview',
                    pdfMapas1: '',
                    pdfMapas2: '',
                    quizUrl: '',
                    aiUrl: '',
                    flashcardsUrl: '',
                    plus: {
                        cronograma: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview',
                        estadistica: 'https://drive.google.com/file/d/1nGApGTnmS7rEuUIDdS18NJ9yya8LszqW/preview',
                        videoclase: 'https://drive.google.com/file/d/1CCJJJuCR8mAVlowPt6fTVhb_8BzX4B27/preview',
                        videoteca: ''
                    }
                }
            },
            'Ol-YTi-vMWQ': { title: 'Mapa Conceptual: Atresias intestinales', publishDate: 'Hace 4 días', description: 'Diagnóstico diferencial.', timeline: [], resources: { pdfEsquema: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview', pdfMapas: '', pdfMapas1: '', pdfMapas2: '', quizUrl: '', aiUrl: '', flashcardsUrl: '', plus: { cronograma: 'https://drive.google.com/file/d/1yoUmjad8toYNPnA6VW8vFlODaesi5qSa/preview', estadistica: '', videoclase: '', videoteca: '' } } },
            'dgk-I0XH60w': { title: 'Mapa Conceptual: Enterocolitis necrotizante', publishDate: 'Hace 5 días', description: 'Manejo de la emergencia.', timeline: [], resources: { pdfEsquema: '', pdfMapas: '', pdfMapas1: '', pdfMapas2: '', quizUrl: '', aiUrl: '', flashcardsUrl: '', plus: { cronograma: '', estadistica: '', videoclase: '', videoteca: '' } } },
            'zXNj5KBWlBw': { title: 'Mapa Conceptual: Estenosis hipertrófica de píloro', publishDate: 'Hace 6 días', description: 'Vómito en proyectil.', timeline: [], resources: { pdfEsquema: '', pdfMapas: '', pdfMapas1: '', pdfMapas2: '', quizUrl: '', aiUrl: '', flashcardsUrl: '', plus: { cronograma: '', estadistica: '', videoclase: '', videoteca: '' } } },
            '0WXQV1HQwXw': { title: 'Mapa Conceptual: Invaginación intestinal', publishDate: 'Hace 1 semana', description: 'Jalea de grosella.', timeline: [], resources: { pdfEsquema: '', pdfMapas: '', pdfMapas1: '', pdfMapas2: '', quizUrl: '', aiUrl: '', flashcardsUrl: '', plus: { cronograma: '', estadistica: '', videoclase: '', videoteca: '' } } },
            'T5PPjhXRpog': { title: 'Mapa Conceptual: Hernia diafragmática', publishDate: 'Hace 1 semana', description: 'Hernia congénita.', timeline: [], resources: { pdfEsquema: '', pdfMapas: '', pdfMapas1: '', pdfMapas2: '', quizUrl: '', aiUrl: '', flashcardsUrl: '', plus: { cronograma: '', estadistica: '', videoclase: '', videoteca: '' } } }  
  
  
};  
  
  

// =========================================================
// === 3. INICIALIZACIÓN Y SEGURIDAD (GATEKEEPER) ===
// =========================================================

window.addEventListener('pageshow', function(event) {
    if (event.persisted) window.location.reload();
});

const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyN_ZakSS4e8AVsle7mZj7uoITW5dWyf5BWT6Nv5NxrbtcrcUM2TNfiGUwmMX8R0AZe/exec';
let player; 
let currentVideoId = ''; 
let fuse; 
let allSubtopicsList = [];
let globalTooltipElement; 
let quickPlayer; 
let currentQuickVideoId = null;
let noteImportFuse = null; 
let tempNoteSession = {};  
let tooltipTimeout = null; 
  
  
// --- FUNCIÓN GLOBAL PARA CERRAR MENÚS DE QUILL ---
window.closeAllQuillPickers = function() {
    document.querySelectorAll('.ql-picker.ql-expanded').forEach(picker => {
        picker.classList.remove('ql-expanded');
        const label = picker.querySelector('.ql-picker-label');
        if (label) label.classList.remove('ql-active');
    });
};  
  
  
// --- CONTROLADOR DE SCROLL PARA CERRAR MENÚS (> 20px) ---
let scrollAccumulator = 0;
let lastScrollTarget = null;
let lastScrollTop = 0;

window.addEventListener('scroll', (e) => {
    // Si no hay menús abiertos, no hacemos nada y reseteamos
    const pickers = document.querySelectorAll('.ql-picker.ql-expanded');
    if (pickers.length === 0) {
        scrollAccumulator = 0;
        return;
    }

    // Evitar cerrar si el scroll se hace DENTRO del mismo menú desplegable (ej. lista de fuentes)
    if (e.target && e.target.classList && e.target.classList.contains('ql-picker-options')) return;

    // Calcular cuánto se ha scrolleado
    const currentScrollTop = e.target.scrollTop || window.scrollY || 0;
    
    if (lastScrollTarget !== e.target) {
        lastScrollTarget = e.target;
        lastScrollTop = currentScrollTop;
        scrollAccumulator = 0;
    } else {
        scrollAccumulator += Math.abs(currentScrollTop - lastScrollTop);
        lastScrollTop = currentScrollTop;
    }

    // Si el acumulado es mayor a 20px, cerramos los menús
    if (scrollAccumulator > 20) {
        window.closeAllQuillPickers();
        scrollAccumulator = 0;
    }
}, true); // El 'true' captura el scroll de cualquier contenedor interno (editing-wrapper, import-wrapper, etc)

// --- CERRAR MENÚS AL HACER CLIC AFUERA ---
document.addEventListener('mousedown', (e) => {
    if (!e.target.closest('.ql-picker')) {
        window.closeAllQuillPickers();
    }
});  
  
  

// Cargar API de YouTube
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

document.addEventListener('DOMContentLoaded', async () => {
    // Inicializar BD
    try {
        await db.init();
    } catch (e) {
        console.error("Fallo crítico al iniciar DB", e);
    }

    const isAuthenticated = checkUserAccess();
    if (!isAuthenticated) return; 

    document.body.classList.remove('security-check-pending');
    await generateAndSyncAllowedIDs();

    const urlParams = new URLSearchParams(window.location.search);
    let videoIdFromUrl = urlParams.get('video');
    
    if (videoIdFromUrl && fullCourseData[videoIdFromUrl]) {
        if (isVideoAccessAllowed(videoIdFromUrl)) {
            currentVideoId = videoIdFromUrl;
        } else {
            currentVideoId = getFirstAllowedVideoId();
        }
    } else {
        currentVideoId = getFirstAllowedVideoId();
    }
    
    if (currentVideoId !== videoIdFromUrl) {
        const newUrl = `${window.location.pathname}?video=${currentVideoId}`;
        window.history.replaceState({ videoId: currentVideoId }, '', newUrl);
    }

    await initializeSidebar(); 
    await loadPageContent(currentVideoId);
    fetchChannelSubscribers();
    await initializeTabs(); 
    initializeNotes(); 
    initializeReorderModal();
    initializeMobileCollapse();
    
    globalTooltipElement = document.getElementById('global-tooltip');
    initializeTooltips(); 
    
    window.addEventListener('popstate', async (event) => {
        if (event.state && event.state.videoId) {
            if (isVideoAccessAllowed(event.state.videoId)) {
                currentVideoId = event.state.videoId;
                await loadPageContent(currentVideoId);
                if (player && player.loadVideoById) {
                    player.loadVideoById(currentVideoId);
                }
                updateActiveSidebarItem(currentVideoId);
                await renderNotesAccordions(currentVideoId);
            } else {
                window.location.reload();
            }
        }
    });
});

  
  
// =====================================================================
// === FIXES GLOBALES PARA QUILL BLOT FORMATTER (IMÁGENES Y VIDEOS) ===
// =====================================================================

// 1. Evitar el "agarre fantasma" de las imágenes (Native Drag)
document.addEventListener('dragstart', function(e) {
    if (e.target.tagName === 'IMG' && e.target.closest('.ql-editor')) {
        e.preventDefault();
    }
});



// 3. Función para forzar la alineación correcta de los 4 cuadrados en elementos dinámicos
function fixBlotFormatterAlignment(quillInstance) {
    quillInstance.on('selection-change', (range) => {
        if (range) {
            setTimeout(() => {
                const formatter = quillInstance.getModule('blotFormatter');
                if (formatter && formatter.currentSpec) {
                    formatter.update(); // Recalcula la posición exacta de los cuadrados
                }
            }, 50); // 50ms le da tiempo al navegador para estabilizar el diseño
        }
    });
}  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
async function generateAndSyncAllowedIDs() {
    const allIDsOnCurrentPage = new Set();
    if (typeof sidebarStructure !== 'undefined') {
        sidebarStructure.forEach(group => {
            group.subtopics.forEach(sub => {
                allIDsOnCurrentPage.add(sub.id);
            });
        });
    }

    const allowedIDsOnCurrentPage = new Set();
    if (typeof sidebarStructure !== 'undefined' && userPermissions) {
        sidebarStructure.forEach(group => {
            if (userPermissions.allowedSidebarGroups.includes(group.topic)) {
                group.subtopics.forEach(sub => {
                    allowedIDsOnCurrentPage.add(sub.id);
                });
            }
        });
    }

    let globalWhitelist = await db.get('global', 'security_map', []);
    globalWhitelist = globalWhitelist.filter(id => !allIDsOnCurrentPage.has(id));

    const newGlobalSet = new Set(globalWhitelist);
    allowedIDsOnCurrentPage.forEach(id => newGlobalSet.add(id));
    const finalAllowedArray = Array.from(newGlobalSet);
    
    try {
        await db.set('global', 'security_map', finalAllowedArray);
        currentGlobalAllowedIDs = new Set(finalAllowedArray);
    } catch (e) {
        console.error("Error guardando seguridad:", e);
    }
}

function getFirstAllowedVideoId() {
    for (const group of sidebarStructure) {
        if (userPermissions.allowedSidebarGroups.includes(group.topic)) {
            if (group.subtopics.length > 0) {
                return group.subtopics[0].id;
            }
        }
    }
    return sidebarStructure[0].subtopics[0].id; 
}

function isVideoAccessAllowed(videoId) {
    return currentGlobalAllowedIDs.has(videoId);
}

function checkUserAccess() {
    try {
        const sessionRaw = sessionStorage.getItem('dashboardData');
        if (!sessionRaw) return false; 
        
        const sessionData = JSON.parse(sessionRaw);
        const status = sessionData.status ? sessionData.status.toLowerCase() : null;

        if (!status || !ROLE_PERMISSIONS[status]) return false; 

        currentUserStatus = status;
        userPermissions = ROLE_PERMISSIONS[status];
        return true;
    } catch (e) {
        console.error("Error verificando seguridad:", e);
        return false;
    }
}

  
  
  
  
  
  
  
  
// Función de seguridad (Respaldo ante fallos)
function setupIframeSafety(iframe, url) {
    iframe.onload = null;
    iframe.onerror = null;
    iframe.onerror = function() {
        console.warn("Error en iframe, reintentando...", url);
        if (url && url !== 'about:blank') {
            setTimeout(() => {
                const separator = url.includes('?') ? '&' : '?';
                iframe.src = `${url}${separator}retry=${Date.now()}`;
            }, 1500);
        }
    };
}

// 1. GESTOR MULTI-IFRAME (Para PDF y Plus: Crea varios iframes y alterna visibilidad)
function manageMultiIframe(container, uniqueId, url) {
    if (!container) return;

    // Ocultar todos los iframes existentes
    const allIframes = container.querySelectorAll('iframe');
    allIframes.forEach(fr => fr.style.display = 'none');

    // Buscar si ya existe este iframe específico
    let targetIframe = container.querySelector(`iframe[data-iframe-id="${uniqueId}"]`);

    // Si no existe, crearlo
    if (!targetIframe) {
        targetIframe = document.createElement('iframe');
        targetIframe.setAttribute('data-iframe-id', uniqueId);
        targetIframe.style.width = '100%';
        targetIframe.style.height = '100%';
        targetIframe.style.border = 'none';
        container.appendChild(targetIframe);
        setupIframeSafety(targetIframe, url);
    }

    // Mostrar el seleccionado
    targetIframe.style.display = 'block';

    // Verificar si la URL cambió (Smart Update)
    const currentSrc = targetIframe.getAttribute('data-loaded-src') || '';
    const newSrc = url || '';

    if (currentSrc !== newSrc) {
        targetIframe.src = newSrc || 'about:blank';
        targetIframe.setAttribute('data-loaded-src', newSrc);
        setupIframeSafety(targetIframe, newSrc);
    }
}

// 2. SMART UPDATE SIMPLE (Para Quiz, IA, Flashcards: Un solo iframe que se actualiza si cambia URL)
function smartUpdateIframe(iframe, newUrl) {
    if (!iframe) return;
    const currentSrc = iframe.getAttribute('data-loaded-src') || '';
    const targetUrl = newUrl || '';

    if (currentSrc !== targetUrl) {
        iframe.src = targetUrl || 'about:blank';
        iframe.setAttribute('data-loaded-src', targetUrl);
        setupIframeSafety(iframe, targetUrl);
    }
}
  
  
  
  
  
  
  
  
  
  
  
// =========================================================
// === 4. LÓGICA DE INTERFAZ DINÁMICA ===
// =========================================================

async function initializeSidebar() {
    const status = await db.get('global', 'course_completion', {});
    buildSidebarHTML(sidebarStructure, status, currentVideoId);
    
    allSubtopicsList = sidebarStructure.flatMap(t => t.subtopics.map(s => ({ ...s, topicTitle: t.topic })));
    
    const fuseOptions = {
        keys: ['title', 'topicTitle'],
        includeScore: true,
        threshold: 0.5, 
        ignoreLocation: true, 
        ignoreFieldNorm: true, 
    };
    fuse = new Fuse(allSubtopicsList, fuseOptions);
    
    populateFilterModal(allSubtopicsList);
    addSidebarListeners(status);
}

function buildSidebarHTML(data, completionStatus, activeVideoId) {
    const listContainer = document.getElementById('sidebar-topic-list');
    if (!listContainer) return;
    
    let html = '';
    
    data.forEach((topic, index) => {
        const isGroupAllowed = userPermissions.allowedSidebarGroups.includes(topic.topic);
        
        let subtopicsHtml = '';
        let topicContainsActiveVideo = false;
        
        topic.subtopics.forEach((sub, i) => { 
            const isCompleted = completionStatus[sub.id] === true;
            const isActive = sub.id === activeVideoId;
            if (isActive) topicContainsActiveVideo = true;
            
            let iconClassUnchecked = '';
            let iconClassChecked = '';
            if (topic.topic === "Guía Fase 2") {
                iconClassUnchecked = 'fi fi-rr-play-circle'; iconClassChecked = 'fi fi-sr-play-circle'; 
            } else if (topic.topic === "VideoTeca 2") {
                iconClassUnchecked = 'fi fi-rr-play-circle'; iconClassChecked = 'fi fi-sr-play-circle'; 
            } else if (topic.topic === "VideoClase 2") {
                iconClassUnchecked = 'fi fi-rr-play-circle'; 
                iconClassChecked = 'fi fi-sr-play-circle';
            } else {
                iconClassUnchecked = 'fi fi-rs-badge-check'; iconClassChecked = 'fi fi-sc-badge-check';
            }
            const initialIconClass = isCompleted ? iconClassChecked : iconClassUnchecked;

            if (isGroupAllowed) {
                subtopicsHtml += `
                    <a href="?video=${sub.id}" class="subtopic-item ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}" data-id="${sub.id}" data-priority="${sub.priority}">
                        <i class="${initialIconClass} subtopic-check-icon priority-${sub.priority} subtopic-check" 
                           data-check-id="${sub.id}"
                           data-icon-checked="${iconClassChecked}"
                           data-icon-unchecked="${iconClassUnchecked}"></i>
                        <span class="subtopic-title">${sub.title}</span>
                    </a>
                `;
            } else {
                subtopicsHtml += `
                    <div class="subtopic-item locked-item" onclick="showLockedTooltip(event)">
                        <i class="fa-solid fa-lock locked-icon"></i>
                        <span class="subtopic-title">${sub.title}</span>
                    </div>
                `;
            }
        });

        html += `
            <div class="topic-group ${topicContainsActiveVideo ? 'open' : ''}">
                <div class="topic-header">
                    <span class="topic-title">${topic.topic}</span>
                    <i class="fa-solid fa-chevron-down topic-toggle-icon"></i>
                </div>
                <div class="subtopic-list">
                    ${subtopicsHtml}
                </div>
            </div>
        `;
    });
    listContainer.innerHTML = html;
} 

async function initializeTabs() {
    const tabsContainer = document.getElementById('tabs-container');
    const tabContentsContainer = document.querySelector('.tab-contents-container');
    if (!tabsContainer) return;
    
    let allPossibleTabs = [
        { id: 'notes-content', icon: 'fa-solid fa-book', label: 'Notas' },
        { id: 'pdf-content', icon: 'fa-solid fa-file-pdf', label: 'PDF' },
        { id: 'plus-content', icon: 'fa-solid fa-circle-plus', label: '+ Plus' },
        { id: 'quiz-content', icon: 'fa-solid fa-pen-to-square', label: 'Preguntas' },
        { id: 'ai-content', icon: 'fa-solid fa-robot', label: 'IA' },
        { id: 'flashcards-content', icon: 'fa-solid fa-clone', label: 'Flashcards' }
    ];

    const savedOrder = await db.get('global', 'tab_order2', []);
    
    if (savedOrder && Array.isArray(savedOrder) && savedOrder.length > 0) {
        allPossibleTabs.sort((a, b) => {
            const indexA = savedOrder.indexOf(a.id);
            const indexB = savedOrder.indexOf(b.id);
            if (indexA !== -1 && indexB !== -1) return indexA - indexB;
            if (indexA !== -1) return -1;
            if (indexB !== -1) return 1;
            return 0;
        });
    }

    tabsContainer.innerHTML = '';

    allPossibleTabs.forEach(tab => {
        const isAllowed = userPermissions.allowedTabs.includes(tab.id);
        const btn = document.createElement('button');
        btn.className = 'tab-button';
        btn.dataset.tabTarget = `#${tab.id}`; 
        
        if (isAllowed) {
            btn.draggable = true;
            btn.innerHTML = `<i class="${tab.icon}"></i> ${tab.label}`;
            btn.addEventListener('click', (e) => { activateTabInternal(btn); });
        } else {
            btn.classList.add('locked-item');
            btn.draggable = true; 
            btn.innerHTML = `<i class="fa-solid fa-lock locked-icon"></i> ${tab.label}`;
            btn.title = "Contenido no disponible en tu plan actual";
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showGlobalTooltip(`<i class='fa-solid fa-lock'></i> Solo usuarios Premium / A+`, e);
            });
        }
        tabsContainer.appendChild(btn);
    });

    setupTabInteractions(tabsContainer, tabContentsContainer);
    
    const activeBtn = tabsContainer.querySelector('.tab-button.active');
    if (!activeBtn) {
        const firstAllowedBtn = tabsContainer.querySelector('.tab-button:not(.locked-item)');
        if (firstAllowedBtn) activateTabInternal(firstAllowedBtn);
    }
}

function activateTabInternal(tabButton) {
    const tabsContainer = document.getElementById('tabs-container');
    const tabContentsContainer = document.querySelector('.tab-contents-container');
    tabsContainer.querySelector('.active')?.classList.remove('active');
    tabContentsContainer.querySelectorAll('.tab-content.active').forEach(c => c.classList.remove('active'));
    tabButton.classList.add('active');
    const targetId = tabButton.dataset.tabTarget;
    if (targetId) {
        const targetContent = tabContentsContainer.querySelector(targetId);
        if (targetContent) targetContent.classList.add('active');
    }
}

function setupTabInteractions(tabsContainer, tabContentsContainer) {
    let draggedTab = null;
    tabsContainer.addEventListener('dragstart', e => { 
        if (e.target.matches('.tab-button:not(.locked-item)')) { 
            draggedTab = e.target; 
            setTimeout(() => e.target.classList.add('dragging'), 0); 
        } else { e.preventDefault(); }
    });
    tabsContainer.addEventListener('dragend', async (e) => { 
        if (draggedTab) { 
            e.target.classList.remove('dragging'); 
            draggedTab = null; 
            const newOrder = [...tabsContainer.children].map(t => t.dataset.tabTarget ? t.dataset.tabTarget.replace('#', '') : null).filter(id => id !== null); 
            await db.set('global', 'tab_order2', newOrder);
        }
    });
    tabsContainer.addEventListener('dragover', e => { 
        e.preventDefault(); 
        const afterElement = [...tabsContainer.querySelectorAll('.tab-button:not(.dragging)')].reduce((closest, child) => { const box = child.getBoundingClientRect(); const offset = e.clientX - box.left - box.width / 2; return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest; }, { offset: Number.NEGATIVE_INFINITY }).element; 
        if (draggedTab) { if (afterElement == null) { tabsContainer.appendChild(draggedTab); } else { tabsContainer.insertBefore(draggedTab, afterElement); } }
    });
    const slider = document.querySelector('.tabs-slider-container'), l = document.getElementById('slide-left-btn'), r = document.getElementById('slide-right-btn');
    const check = () => { if (tabsContainer.scrollWidth > tabsContainer.clientWidth) { slider.classList.add('is-scrollable'); l.style.display = tabsContainer.scrollLeft > 1 ? 'grid' : 'none'; r.style.display = tabsContainer.scrollLeft < tabsContainer.scrollWidth - tabsContainer.clientWidth - 1 ? 'grid' : 'none'; } else { slider.classList.remove('is-scrollable'); l.style.display = r.style.display = 'none'; } };
    l.addEventListener('click', () => tabsContainer.scrollLeft -= tabsContainer.clientWidth * 0.8);
    r.addEventListener('click', () => tabsContainer.scrollLeft += tabsContainer.clientWidth * 0.8);
    tabsContainer.addEventListener('scroll', check, { passive: true });
    window.addEventListener('resize', check);
    setTimeout(check, 100);
}

function showLockedTooltip(event) {
    showGlobalTooltip("<b>Acceso Restringido</b><br>Disponible en plan superior.", event);
}

// =========================================================
// === 5. CARGA DE CONTENIDO Y REPRODUCCIÓN ===
// =========================================================

window.onYouTubeIframeAPIReady = function() {
    if (!isVideoAccessAllowed(currentVideoId)) return;
    player = new YT.Player('youtube-player', {
        height: '390', width: '640', videoId: currentVideoId,
        playerVars: { 'playsinline': 1, 'origin': window.location.origin, 'rel': 0, 'modestbranding': 1, 'iv_load_policy': 3, 'controls': 1, 'disablekb': 0, 'fs': 1 },
        events: { 'onReady': onPlayerReady, 'onError': onPlayerError, 'onStateChange': onPlayerStateChange }
    });
};

function onPlayerReady(event) { updateVideoDuration(); }
function onPlayerStateChange(event) { if (event.data === YT.PlayerState.CUED || event.data === YT.PlayerState.PLAYING) updateVideoDuration(); }
function updateVideoDuration() {
     if (player && typeof player.getDuration === 'function') {
        const duration = player.getDuration();
        if (duration > 0) { 
            const minutes = Math.floor(duration / 60);
            const seconds = Math.floor(duration % 60).toString().padStart(2, '0');
            document.getElementById('video-duration').innerHTML = `<i class="fa-regular fa-clock"></i> ${minutes}:${seconds}`;
        }
     }
}
function onPlayerError(event) { console.error('Error YT:', event.data); }
function formatTime(s) { const m = Math.floor(s / 60); const sec = Math.floor(s % 60).toString().padStart(2, '0'); return `${m}:${sec}`; }
function parseTime(t) { if (!t) return null; const p = t.split(':'); if (p.length === 1) return parseInt(p[0], 10); if (p.length === 2) return (parseInt(p[0], 10) * 60) + parseInt(p[1], 10); return null; }

function showGlobalTooltip(text, event) {
    if (!globalTooltipElement) globalTooltipElement = document.getElementById('global-tooltip');
    if (!globalTooltipElement) return;
    if (tooltipTimeout) clearTimeout(tooltipTimeout);
    globalTooltipElement.innerHTML = text;
    globalTooltipElement.classList.add('visible');
    moveGlobalTooltip(event);
    tooltipTimeout = setTimeout(() => { hideGlobalTooltip(); }, 3000);
}

function moveGlobalTooltip(event) {
     if (!globalTooltipElement || !globalTooltipElement.classList.contains('visible')) return;
     const tooltipRect = globalTooltipElement.getBoundingClientRect();
     let top = event.clientY - tooltipRect.height - 35; 
     let left = event.clientX - (tooltipRect.width / 2); 
     if (top < 10) top = event.clientY + 35; 
     if (left < 10) left = 10;
     if (left + tooltipRect.width > window.innerWidth - 10) left = window.innerWidth - tooltipRect.width - 10;
     globalTooltipElement.style.top = `${top}px`;
     globalTooltipElement.style.left = `${left}px`;
}

function hideGlobalTooltip() {
    if (!globalTooltipElement) globalTooltipElement = document.getElementById('global-tooltip');
    if (globalTooltipElement) {
        globalTooltipElement.classList.remove('visible');
        if (tooltipTimeout) clearTimeout(tooltipTimeout);
    }
}

function initializeDraggable(wrapper) {
    if (!wrapper) return;
    let isDown = false, startX, scrollLeft;
    wrapper.addEventListener('mousedown', e => { if (e.target.closest('button')) return; isDown = true; wrapper.classList.add('grabbing'); startX = e.pageX - wrapper.offsetLeft; scrollLeft = wrapper.scrollLeft; });
    wrapper.addEventListener('mouseleave', () => { isDown = false; wrapper.classList.remove('grabbing'); });
    wrapper.addEventListener('mouseup', () => { isDown = false; wrapper.classList.remove('grabbing'); });
    wrapper.addEventListener('mousemove', e => { if (!isDown) return; e.preventDefault(); const x = e.pageX - wrapper.offsetLeft; const walk = (x - startX) * 2; wrapper.scrollLeft = scrollLeft - walk; });
}

function initializeTooltips() {
    const sidebarList = document.getElementById('sidebar-topic-list');
    const tabsContainer = document.querySelector('.tabs-slider-container');
    const commentsSection = document.querySelector('.comments-section.card');
    if (sidebarList) {
        sidebarList.addEventListener('mouseover', (e) => { if (e.target.closest('.locked-item')) return; const item = e.target.closest('.subtopic-item'); const sidebar = document.querySelector('.app-sidebar'); if (item && sidebar.classList.contains('collapsed') && window.innerWidth > 1100) showGlobalTooltip('<b>Click icono =</b> Completo<br>', e); });
        sidebarList.addEventListener('mouseout', (e) => hideGlobalTooltip());
        sidebarList.addEventListener('mousemove', (e) => { const item = e.target.closest('.subtopic-item'); if (item && globalTooltipElement.classList.contains('visible')) moveGlobalTooltip(e); });
    }
    if (tabsContainer) {
        tabsContainer.addEventListener('mouseover', (e) => { if (e.target.closest('.locked-item')) return; if (e.target.closest('.tabs')) showGlobalTooltip('Arrastra y reordena', e); });
        tabsContainer.addEventListener('mouseout', (e) => hideGlobalTooltip());
        tabsContainer.addEventListener('mousemove', (e) => { if (globalTooltipElement.classList.contains('visible') && e.target.closest('.tabs')) moveGlobalTooltip(e); });
    }
    if (commentsSection) {
        commentsSection.addEventListener('mouseover', (e) => { if (e.target.closest('p.comments-motivation-message') || e.target.closest('h2')) { hideGlobalTooltip(); return; } showGlobalTooltip('Click para comentar.', e); });
        commentsSection.addEventListener('mouseout', () => hideGlobalTooltip());
        commentsSection.addEventListener('mousemove', (e) => { if (globalTooltipElement.classList.contains('visible') && !e.target.closest('p.comments-motivation-message') && !e.target.closest('h2')) moveGlobalTooltip(e); else hideGlobalTooltip(); });
    }
}

  
  
  
  
  
  
  
  

async function loadPageContent(videoId) {
    if (!isVideoAccessAllowed(videoId)) {
        document.getElementById('video-title').textContent = "Contenido Bloqueado";
        document.getElementById('video-description').innerHTML = "<i class='fa-solid fa-lock'></i> No tienes permisos para ver este video en esta sección.";
        document.getElementById('youtube-player').innerHTML = ""; 
        return;
    }
    const data = fullCourseData[videoId];
    if (!data) return;

    // --- Carga de Textos (Igual que antes) ---
    document.getElementById('video-title').textContent = data.title;
    document.getElementById('video-publish-date').textContent = data.publishDate;
    document.getElementById('video-description').textContent = data.description;
    document.getElementById('current-video-note-title').textContent = data.title;
    document.title = `${data.title} | AcaMedic`;

    buildTimelineCarousel(data.timeline, videoId);
    
    // --- Lógica de Like (Igual que antes) ---
    const LIKE_KEY = `video_like_${videoId}`;
    const likeBtn = document.getElementById('like-btn');
    const isLiked = await db.get('global', LIKE_KEY);
    
    likeBtn.classList.toggle('liked', isLiked === 'liked');
    likeBtn.onclick = async () => {
        window.open(`https://www.youtube.com/watch?v=${videoId}`, '_blank');
        likeBtn.classList.toggle('liked');
        await db.set('global', LIKE_KEY, likeBtn.classList.contains('liked') ? 'liked' : '');
    };

    document.getElementById('comment-yt-btn').href = `https://www.youtube.com/watch?v=${videoId}`;
    
    // --- Comentarios Facebook (Igual que antes) ---
    const fbContainer = document.querySelector('.fb-comments-container');
    const newUrl = window.location.href; 
    fbContainer.innerHTML = ''; 
    const newFbDiv = document.createElement('div');
    newFbDiv.className = 'fb-comments';
    newFbDiv.setAttribute('data-href', newUrl);
    newFbDiv.setAttribute('data-width', '100%');
    newFbDiv.setAttribute('data-numposts', '5');
    newFbDiv.setAttribute('data-lazy', 'true');
    fbContainer.appendChild(newFbDiv);
    if (window.FB && window.FB.XFBML) { window.FB.XFBML.parse(fbContainer); }

    // --- AQUÍ ESTÁ EL CAMBIO IMPORTANTE: IFRAMES INTELIGENTES ---

    // 1. Quiz, IA, Flashcards (Usamos la nueva función smartUpdateIframe)
    if (userPermissions.allowedTabs.includes('quiz-content')) {
        smartUpdateIframe(document.querySelector('#quiz-content iframe'), data.resources.quizUrl);
    }
    if (userPermissions.allowedTabs.includes('ai-content')) {
        smartUpdateIframe(document.querySelector('#ai-content iframe'), data.resources.aiUrl);
    }
    if (userPermissions.allowedTabs.includes('flashcards-content')) {
        smartUpdateIframe(document.querySelector('#flashcards-content iframe'), data.resources.flashcardsUrl);
    }

// 2. PDF (Mantiene la selección del usuario - Lógica Nueva)
    if (userPermissions.allowedTabs.includes('pdf-content')) {
        updatePdfContentForVideo(videoId);
    }

    // 3. Plus (Optimizado)
    if (userPermissions.allowedTabs.includes('plus-content')) {
        updatePlusContentForVideo(videoId);
    }

    // --- Reproductor Youtube (Igual que antes) ---
    if (player && typeof player.loadVideoById === 'function') player.loadVideoById(videoId);
    document.getElementById('video-duration').innerHTML = `<i class="fa-regular fa-clock"></i> --:--`; 
}
  
  
  
  
  
  
  
let currentPdfIndex = 0; 
  
function updatePdfContentForVideo(videoId) {
    const wrapper = document.querySelector('#pdf-content .pdf-options');
    const iframeContainer = document.querySelector('#pdf-content .pdf-iframe-container');
    const floatingBtn = document.querySelector('#pdf-content .pdf-floating-button');
    const data = fullCourseData[videoId];

    if (!wrapper || !iframeContainer || !data) return;

    // 1. Definimos las opciones posibles y sus etiquetas
    // Ajusta los nombres ("VideoTeca 2", etc.) según tus preferencias
    const allOptions = [
        { name: 'VideoTeca 2', url: data.resources.pdfEsquema },
        { name: 'VideoClase 2', url: data.resources.pdfMapas },
        { name: 'VideoTeca Extra', url: data.resources.pdfMapas1 }, // Si usas mapas1
        { name: 'VideoClase Extra', url: data.resources.pdfMapas2 }  // Si usas mapas2
    ];

    // 2. Filtramos solo las opciones que tienen URL válida
    const validIframeIds = new Set();
    const validOptions = [];

    allOptions.forEach((opt, index) => {
        if (opt.url && opt.url.trim() !== '') { 
            // Corrección de URL (/view -> /preview) igual que antes
            let finalUrl = opt.url;
            if (finalUrl.includes('/view')) finalUrl = finalUrl.replace('/view', '/preview');
            
            // Guardamos la URL procesada
            opt.url = finalUrl;
            
            validIframeIds.add(`pdf-${index}`); 
            validOptions.push({ ...opt, originalIndex: index });
        }
    });

    // 3. LIMPIEZA INTELIGENTE (Garbage Collection)
    const existingIframes = Array.from(iframeContainer.querySelectorAll('iframe[data-iframe-id]'));
    existingIframes.forEach(iframe => {
        const currentId = iframe.getAttribute('data-iframe-id');
        if (!validIframeIds.has(currentId)) {
            iframe.remove();
        }
    });

    // 4. Renderizado de Botones
    wrapper.innerHTML = '';
    
    if (validOptions.length === 0) {
        iframeContainer.innerHTML = '<p style="padding:2rem; text-align:center; color:#888;">No hay documentos PDF disponibles.</p>';
        if (floatingBtn) floatingBtn.style.display = 'none';
        return;
    }

    // Limpiar mensaje de "No hay documentos" si existe
    const msg = iframeContainer.querySelector('p');
    if(msg) msg.remove();

    let activeOption = null;

    validOptions.forEach((opt) => {
        const btn = document.createElement('button');
        btn.className = 'pdf-option-btn options-pill-btn'; // Clase específica para evento click
        btn.dataset.iframeSrc = opt.url;
        btn.dataset.idx = opt.originalIndex;
        btn.textContent = opt.name;

        // Mantener selección o seleccionar el primero si el actual ya no existe
        if (opt.originalIndex === currentPdfIndex) {
            btn.classList.add('active');
            activeOption = opt;
        }
        wrapper.appendChild(btn);
    });

    // Fallback: Si la opción activa no existe en este video, usar la primera
    if (!activeOption && validOptions.length > 0) {
        wrapper.children[0].classList.add('active');
        activeOption = validOptions[0];
        currentPdfIndex = activeOption.originalIndex;
    }

    // 5. Mostrar contenido y actualizar botón flotante
    if (activeOption) {
        manageMultiIframe(iframeContainer, `pdf-${activeOption.originalIndex}`, activeOption.url);
        
        // Actualizar botón flotante
        if (floatingBtn) {
            floatingBtn.href = activeOption.url;
            floatingBtn.style.display = 'flex';
            // Mover el botón al final para que quede sobre el iframe (z-index)
            iframeContainer.appendChild(floatingBtn); 
        }
    }

    initializePdfCarousel(iframeContainer, floatingBtn);
}
  
  
function initializePdfCarousel(iframeContainer, floatingBtn) {
    const wrapper = document.querySelector('#pdf-content .pdf-options');
    if (!wrapper) return;
    
    const l = document.getElementById('pdf-slide-left-btn'); 
    const r = document.getElementById('pdf-slide-right-btn');

    // Inicializar drag una sola vez
    if (!wrapper.dataset.dragInit) {
        initializeDraggable(wrapper);
        wrapper.dataset.dragInit = "true";
    }
    
    // Evento Click Delegado (Mejor rendimiento)
    wrapper.onclick = e => {
        const btn = e.target.closest('.pdf-option-btn'); 
        if (!btn) return;
        if (wrapper.classList.contains('grabbing')) return; // Evitar click si se está arrastrando
        
        // 1. UI Update
        wrapper.querySelector('.active')?.classList.remove('active'); 
        btn.classList.add('active');
        
        // 2. Logic Update
        currentPdfIndex = parseInt(btn.dataset.idx);
        const url = btn.dataset.iframeSrc;
        
        // 3. Cambiar Iframe
        manageMultiIframe(iframeContainer, `pdf-${currentPdfIndex}`, url);

        // 4. Actualizar Botón Flotante
        if (floatingBtn) {
            floatingBtn.href = url;
            floatingBtn.style.display = 'flex';
        }
    };
    
    // Flechas del carrusel
    const check = () => { 
        if(!l || !r) return;
        l.style.display = wrapper.scrollLeft > 1 ? 'grid' : 'none'; 
        r.style.display = wrapper.scrollLeft < wrapper.scrollWidth - wrapper.clientWidth - 1 ? 'grid' : 'none'; 
    };
    
    if(l) l.onclick = () => wrapper.scrollLeft -= wrapper.clientWidth * 0.8;
    if(r) r.onclick = () => wrapper.scrollLeft += wrapper.clientWidth * 0.8;
    
    wrapper.onscroll = check; 
    setTimeout(check, 150);
}  
  
  
  
  
  
  
  
  

function buildTimelineCarousel(timelineData = [], videoId) {
    const wrapper = document.getElementById('timeline-items-wrapper');
    const leftBtn = document.getElementById('timeline-slide-left-btn');
    const rightBtn = document.getElementById('timeline-slide-right-btn');
    wrapper.innerHTML = ''; 
    if (timelineData.length === 0) {
        wrapper.innerHTML = '<p style="color:#8a8f9d; padding: 1rem;">No hay línea de tiempo para este video.</p>';
    } else {
        timelineData.forEach(item => {
            const el = document.createElement('a');
            el.className = 'timeline-item';
            el.dataset.time = item.time;
            el.innerHTML = `<div class="timeline-thumbnail"><img src="https://img.youtube.com/vi/${videoId}/mqdefault.jpg" draggable="false"></div><div class="timeline-content"><span class="timestamp">${formatTime(item.time)}</span><span class="title">${item.title}</span></div>`;
            wrapper.appendChild(el);
        });
    }
    const checkArrows = () => {
        if (!wrapper || timelineData.length === 0) { leftBtn.style.display = rightBtn.style.display = 'none'; return; }
        leftBtn.style.display = wrapper.scrollLeft > 1 ? 'grid' : 'none';
        rightBtn.style.display = wrapper.scrollLeft < wrapper.scrollWidth - wrapper.clientWidth - 1 ? 'grid' : 'none';
    };
    initializeDraggable(wrapper);
    wrapper.querySelectorAll('.timeline-item').forEach(item => {
        item.onclick = e => { 
            if (wrapper.classList.contains('grabbing')) return; 
            const t = parseInt(item.dataset.time, 10); 
            if (player) player.seekTo(t, true); 
        };
    });
    leftBtn.onclick = () => wrapper.scrollLeft -= wrapper.clientWidth * 0.8;
    rightBtn.onclick = () => wrapper.scrollLeft += wrapper.clientWidth * 0.8;
    wrapper.onscroll = checkArrows;
    checkArrows();
}

async function fetchChannelSubscribers() {
    try {
        const response = await fetch(`${APPS_SCRIPT_URL}?action=getChannelData`);
        const data = await response.json();
        if (!data.error) document.getElementById('subscriber-count').textContent = `${new Intl.NumberFormat('es-ES', { notation: 'compact' }).format(data.subscribers)} suscriptores`;
    } catch (e) { console.error(e); }
}


  
  
  
  
  
// Variable global para Plus
let currentPlusIndex = 0;

function updatePlusContentForVideo(videoId) {
    const wrapper = document.querySelector('#plus-content .plus-options');
    const iframeContainer = document.querySelector('#plus-content .plus-iframe-container');
    const data = fullCourseData[videoId];

    if (!wrapper || !iframeContainer || !data || !data.resources.plus) return;

    // 1. Definimos las opciones posibles para mantener los IDs consistentes (0, 1, 2, 3)
    const allOptions = [
        { name: 'Cronograma', url: data.resources.plus.cronograma },
        { name: 'Estadistica', url: data.resources.plus.estadistica },
        { name: 'Hoja: VideoClase', url: data.resources.plus.videoclase },
        { name: 'Hoja: VideoTeca', url: data.resources.plus.videoteca }
    ];

    // 2. Identificamos qué IDs son VÁLIDOS para este video específico
    // (Ejemplo: Si el video solo tiene Cronograma y Videoteca, los IDs válidos son "plus-0" y "plus-3")
    const validIframeIds = new Set();
    const validOptions = [];

    allOptions.forEach((opt, index) => {
        if (opt.url) { 
            validIframeIds.add(`plus-${index}`); // Guardamos el ID que esperamos ver
            validOptions.push({ ...opt, originalIndex: index });
        }
    });

    // =========================================================================
    // === 3. LIMPIEZA INTELIGENTE (GARBAGE COLLECTION) ===
    // =========================================================================
    
    // Obtenemos todos los iframes que existen actualmente en el contenedor
    const existingIframes = Array.from(iframeContainer.querySelectorAll('iframe[data-iframe-id]'));
    
    existingIframes.forEach(iframe => {
        const currentId = iframe.getAttribute('data-iframe-id');
        
        // CONDICIÓN CLAVE: 
        // Si el iframe actual NO está en la lista de IDs válidos para el nuevo video -> SE ELIMINA.
        // Si SÍ está, NO SE TOCA (se recicla).
        if (!validIframeIds.has(currentId)) {
            iframe.remove();
        }
    });
    
    // =========================================================================

    // 4. Renderizado de Botones (Igual que antes)
    wrapper.innerHTML = '';
    
    if (validOptions.length === 0) {
        // Si no hay recursos, limpiamos todo y mostramos mensaje
        iframeContainer.innerHTML = '<p style="padding:2rem; text-align:center; color:#888;">No hay recursos Plus adicionales.</p>';
        return;
    }

    // Limpiar mensaje de texto si existía, pero NO tocar los iframes
    const msg = iframeContainer.querySelector('p');
    if(msg) msg.remove();

    let activeOption = null;

    validOptions.forEach((opt) => {
        const btn = document.createElement('button');
        btn.className = 'plus-option-btn options-pill-btn';
        btn.dataset.iframeSrc = opt.url;
        btn.dataset.idx = opt.originalIndex;
        btn.textContent = opt.name;

        // Mantener la selección del usuario si existe en este video
        if (opt.originalIndex === currentPlusIndex) {
            btn.classList.add('active');
            activeOption = opt;
        }
        wrapper.appendChild(btn);
    });

    // Fallback: Si la opción que el usuario veía no existe en este video, activar la primera disponible
    if (!activeOption && validOptions.length > 0) {
        wrapper.children[0].classList.add('active');
        activeOption = validOptions[0];
        currentPlusIndex = activeOption.originalIndex;
    }

    // 5. Cargar/Actualizar SOLO el iframe activo
    // (Tu función manageMultiIframe se encargará de crear el iframe si no sobrevivió a la limpieza,
    // o de actualizar la URL si sobrevivió pero el link cambió)
    if (activeOption) {
        manageMultiIframe(iframeContainer, `plus-${activeOption.originalIndex}`, activeOption.url);
    }

    initializePlusCarousel(iframeContainer);
}

function initializePlusCarousel(iframeContainer) {
    const wrapper = document.querySelector('#plus-content .plus-options');
    if (!wrapper) return;
    
    const l = document.getElementById('plus-slide-left-btn'); 
    const r = document.getElementById('plus-slide-right-btn');

    // Inicializar drag una sola vez
    if (!wrapper.dataset.dragInit) {
        initializeDraggable(wrapper);
        wrapper.dataset.dragInit = "true";
    }
    
    // Evento Click Delegado
    wrapper.onclick = e => {
        const btn = e.target.closest('.plus-option-btn'); 
        if (!btn) return;
        if (wrapper.classList.contains('grabbing')) return;
        
        // 1. UI Update (Botones)
        wrapper.querySelector('.active')?.classList.remove('active'); 
        btn.classList.add('active');
        
        // 2. Logic Update
        currentPlusIndex = parseInt(btn.dataset.idx);
        const url = btn.dataset.iframeSrc;
        
        // 3. CAMBIO DE PESTAÑA (Sin recarga si ya existe)
        // Usamos el ID único basado en el índice (ej: plus-0, plus-1)
        manageMultiIframe(iframeContainer, `plus-${currentPlusIndex}`, url);
    };
    
    // Flechas del carrusel
    const check = () => { 
        if(!l || !r) return;
        l.style.display = wrapper.scrollLeft > 1 ? 'grid' : 'none'; 
        r.style.display = wrapper.scrollLeft < wrapper.scrollWidth - wrapper.clientWidth - 1 ? 'grid' : 'none'; 
    };
    if(l) l.onclick = () => wrapper.scrollLeft -= wrapper.clientWidth * 0.8;
    if(r) r.onclick = () => wrapper.scrollLeft += wrapper.clientWidth * 0.8;
    wrapper.onscroll = check; 
    setTimeout(check, 150);
}
  
  
  
  
  

// =========================================================
// === 6. SIDEBAR LOGIC Y FILTROS ===
// =========================================================

function populateFilterModal(subtopics) {
    const list = document.getElementById('filter-subtopics-list');
    list.innerHTML = '';
    subtopics.forEach(sub => { list.innerHTML += `<label><input type="checkbox" name="filter-subtopic" value="${sub.id}"> <span>${sub.title}</span></label>`; });
}

function addSidebarListeners(completionStatus) {
    const sidebar = document.querySelector('.app-sidebar');
    const toggleBtn = document.querySelector('#sidebar-toggle-btn'); 
    const mobileMenuBtn = document.getElementById('mobile-menu-btn');
    const mobileCloseBtn = document.getElementById('sidebar-close-btn'); 
    const topicList = document.getElementById('sidebar-topic-list');

    async function toggleSubtopicCompletion(checkBtn) {
        const subId = checkBtn.dataset.checkId;
        const item = checkBtn.closest('.subtopic-item');
        if (item.classList.contains('locked-item')) return;
        const isCompleted = !item.classList.contains('completed');
        completionStatus[subId] = isCompleted;
        item.classList.toggle('completed', isCompleted);
        const checkedIcon = checkBtn.dataset.iconChecked;
        const uncheckedIcon = checkBtn.dataset.iconUnchecked;
        const baseClasses = `subtopic-check-icon priority-${item.dataset.priority} subtopic-check`;
        checkBtn.className = `${baseClasses} ${isCompleted ? checkedIcon : uncheckedIcon}`;
        await db.set('global', 'course_completion', completionStatus);
    }
    
    sidebar.addEventListener('mouseenter', () => { if (window.innerWidth > 1400) document.body.classList.add('sidebar-hover-active'); });
    sidebar.addEventListener('mouseleave', () => { if (window.innerWidth > 1400) document.body.classList.remove('sidebar-hover-active'); });

    const handleSidebarToggle = () => {
        if (window.innerWidth <= 1100) {
            sidebar.classList.toggle('mobile-open');
            if (sidebar.classList.contains('mobile-open')) document.body.classList.add('overlay-active');
            else document.body.classList.remove('overlay-active');
        } else {
            sidebar.classList.toggle('collapsed');
            document.body.classList.toggle('sidebar-collapsed');
            if (!sidebar.classList.contains('collapsed')) document.body.classList.add('overlay-active');
            else document.body.classList.remove('overlay-active');
        }
    };

    const overlay = document.getElementById('sidebar-overlay');
    if (overlay) {
        overlay.addEventListener('click', () => {
            sidebar.classList.remove('mobile-open');
            if (window.innerWidth > 1100) { sidebar.classList.add('collapsed'); document.body.classList.add('sidebar-collapsed'); }
            document.body.classList.remove('overlay-active');
        });
    }

    if (toggleBtn) toggleBtn.addEventListener('click', handleSidebarToggle);
    if (mobileMenuBtn) mobileMenuBtn.addEventListener('click', handleSidebarToggle);
    if (mobileCloseBtn) mobileCloseBtn.addEventListener('click', handleSidebarToggle); 

    topicList.addEventListener('click', async (e) => {
        const width = window.innerWidth;
        const isMobile = width <= 1100;
        const isTabletCollapsed = sidebar.classList.contains('collapsed') && width <= 1400 && width > 1100;
        const lockedGroup = e.target.closest('.topic-group.locked-item');
        if (lockedGroup) return; 

        const topicHeader = e.target.closest('.topic-header');
        if (topicHeader) {
            if (!isTabletCollapsed) {
                const group = topicHeader.parentElement;
                group.classList.toggle('open');
            }
            return;
        }
        
        const checkBtn = e.target.closest('.subtopic-check');
        if (checkBtn) {
            if (!isTabletCollapsed) {
                e.preventDefault();
                await toggleSubtopicCompletion(checkBtn); 
                return;
            }
        }
        
        const subtopicLink = e.target.closest('.subtopic-item');
        if (subtopicLink && !subtopicLink.classList.contains('locked-item')) {
            e.preventDefault();
            const newVideoId = subtopicLink.dataset.id;
            if (newVideoId !== currentVideoId) {
                if (!isVideoAccessAllowed(newVideoId)) {
                     showGlobalTooltip("<i class='fa-solid fa-lock'></i> Acceso denegado.", e);
                     return;
                }
                currentVideoId = newVideoId;
                const newUrl = `${window.location.pathname}?video=${currentVideoId}`;
                window.history.pushState({ videoId: currentVideoId }, fullCourseData[currentVideoId].title, newUrl);
                await loadPageContent(currentVideoId); 
                updateActiveSidebarItem(currentVideoId);
                await renderNotesAccordions(currentVideoId);
            }
            if (isMobile) {
                sidebar.classList.remove('mobile-open');
                document.body.classList.remove('overlay-active');
            }
        }
    });

    topicList.addEventListener('dblclick', async (e) => {
        const isCollapsed = sidebar.classList.contains('collapsed') && window.innerWidth <= 1400 && window.innerWidth > 1100;
        if (!isCollapsed) return;
        const subtopicLink = e.target.closest('.subtopic-item');
        if (subtopicLink && !subtopicLink.classList.contains('locked-item')) {
            e.preventDefault();
            const checkBtn = subtopicLink.querySelector('.subtopic-check');
            if(checkBtn) await toggleSubtopicCompletion(checkBtn);
        }
    });

    const modal = document.getElementById('filter-modal-backdrop');
    document.getElementById('filter-btn').addEventListener('click', () => modal.classList.add('visible'));
    document.getElementById('close-filter-modal-btn').addEventListener('click', () => modal.classList.remove('visible'));
    document.getElementById('apply-filters-btn').addEventListener('click', () => { applyFilters(); modal.classList.remove('visible'); });
    document.getElementById('reset-filters-btn').addEventListener('click', () => {
        document.querySelectorAll('input[name="filter-status"][value="all"]')[0].checked = true;
        document.querySelectorAll('input[name="filter-priority"][value="all"]')[0].checked = true;
        document.querySelectorAll('#filter-subtopics-list input').forEach(cb => cb.checked = false);
        applyFilters();
        modal.classList.remove('visible');
    });
    document.getElementById('search-subtopics').addEventListener('input', applyFilters);
}

function updateActiveSidebarItem(activeId) {
    document.querySelectorAll('.subtopic-item.active').forEach(item => item.classList.remove('active'));
    const newActiveItem = document.querySelector(`.subtopic-item[data-id="${activeId}"]`);
    if (newActiveItem) {
        newActiveItem.classList.add('active');
        const parentTopic = newActiveItem.closest('.topic-group');
        if (parentTopic && !parentTopic.classList.contains('open') && !parentTopic.classList.contains('locked-item')) {
            parentTopic.classList.add('open');
        }
    }
}

function applyFilters() {
    const searchVal = document.getElementById('search-subtopics').value.toLowerCase();
    const statusVal = document.querySelector('input[name="filter-status"]:checked').value;
    const priorityVal = document.querySelector('input[name="filter-priority"]:checked').value;
    const checkedSubtopicIds = [...document.querySelectorAll('#filter-subtopics-list input:checked')].map(cb => cb.value);
    
    let searchResultIds = null;
    if (searchVal.length > 1) {
        searchResultIds = fuse.search(searchVal).map(r => r.item.id);
    }

    document.querySelectorAll('.topic-group').forEach(topic => {
        if(topic.classList.contains('locked-item')) return;
        let hasVisible = false;
        topic.querySelectorAll('.subtopic-item').forEach(sub => {
            const subId = sub.dataset.id;
            const priority = sub.dataset.priority;
            const isCompleted = sub.classList.contains('completed');
            const searchMatch = !searchResultIds || searchResultIds.includes(subId);
            let statusMatch = (statusVal === 'all') || (statusVal === 'completed' && isCompleted) || (statusVal === 'pending' && !isCompleted);
            let priorityMatch = (priorityVal === 'all') || (priority === priorityVal);
            let subtopicMatch = (checkedSubtopicIds.length === 0) || checkedSubtopicIds.includes(subId);

            if (searchMatch && statusMatch && priorityMatch && subtopicMatch) {
                sub.style.display = 'flex';
                hasVisible = true;
            } else {
                sub.style.display = 'none';
            }
        });
        topic.style.display = hasVisible ? 'block' : 'none';
        if (searchVal.length > 0 && hasVisible) topic.classList.add('open');
    });
}

function initializeMobileCollapse() {
    const section = document.querySelector('.interactive-section.card'), header = document.querySelector('.interactive-header');
    if(header) header.addEventListener('click', () => section.classList.toggle('collapsed'));
}

function initializeReorderModal() {
    const container = document.getElementById('tabs-container');
    const btn = document.getElementById('reorder-tabs-btn');
    const modal = document.getElementById('reorder-modal-backdrop');
    const close = document.getElementById('close-reorder-modal');
    const list = document.getElementById('reorder-list');
    if (!btn) return;
    function updateButtons() { list.querySelectorAll('.reorder-item').forEach((item, idx) => { item.querySelector('.move-tab-up').disabled = idx===0; item.querySelector('.move-tab-down').disabled = idx===list.children.length-1; }); }
    function populate() {
        list.innerHTML = '';
        [...container.children].forEach(tab => {
            if(!tab.classList.contains('tab-button') || tab.classList.contains('locked-item')) return;
            const item = document.createElement('div'); item.className = 'reorder-item'; item.dataset.target = tab.dataset.tabTarget;
            item.innerHTML = `<span><i class="${tab.querySelector('i').className}"></i> ${tab.innerText}</span><div class="reorder-item-controls"><button class="move-tab-up"><i class="fa-solid fa-arrow-up"></i></button><button class="move-tab-down"><i class="fa-solid fa-arrow-down"></i></button></div>`;
            list.appendChild(item);
        });
        updateButtons();
    }
    btn.addEventListener('click', () => { populate(); modal.classList.add('visible'); });
    close.addEventListener('click', async () => {
        const newOrder = [...list.querySelectorAll('.reorder-item')].map(i => i.dataset.target);
        await db.set('global', 'tab_order2', newOrder);
        newOrder.forEach(id => { const t = container.querySelector(`[data-tab-target="${id}"]`); if(t) container.appendChild(t); });
        const first = container.querySelector('.tab-button:not(.locked-item)');
        if(first) first.click();
        modal.classList.remove('visible');
    });
    list.addEventListener('click', e => {
        const item = e.target.closest('.reorder-item'); if(!item) return;
        if (e.target.closest('.move-tab-up')) { if(item.previousElementSibling) list.insertBefore(item, item.previousElementSibling); }
        else if (e.target.closest('.move-tab-down')) { if(item.nextElementSibling) list.insertBefore(item.nextElementSibling, item); }
        updateButtons();
    });
}

/* --- CONFIGURACIÓN AVANZADA DE QUILL --- */
var Font = Quill.import('formats/font');
// IMPORTANTE: Estos nombres deben coincidir con las clases .ql-font-NOMBRE del CSS
Font.whitelist = [
  'roboto', 'open-sans', 'lato', 'montserrat', 'oswald', 'raleway', 
  'merriweather', 'nunito', 'playfair', 'poppins', 'ubuntu', 
  'dancing-script', 'pacifico', 'arial' 
];
Quill.register(Font, true);

var Size = Quill.import('attributors/style/size');
// Permitimos cualquier tamaño (validación flexible para el input manual)
Size.whitelist = ['10px', '12px', '14px', '16px', '18px', '20px', '24px', '30px', '36px', '48px', '60px', '72px'];
Quill.register(Size, true);

  


  
/* --- CONFIGURACIÓN DE INTERLINEADO (LINE HEIGHT) --- */
var Parchment = Quill.import('parchment');
// Usamos 'style' para que se guarde como style="line-height: 1.5" (mejor compatibilidad)
var LineHeightStyle = new Parchment.Attributor.Style('lineheight', 'line-height', {
    scope: Parchment.Scope.INLINE,
    whitelist: ['1', '1.15', '1.5', '2', '2.5', '3']
});
Quill.register(LineHeightStyle, true);
  

  
  
  
// Verificamos que la librería cargó correctamente desde el CDN
if (window.QuillBlotFormatter) {
    Quill.register('modules/blotFormatter', window.QuillBlotFormatter.default);
} else {
    console.error("QuillBlotFormatter no se ha cargado. Verifica el CDN en el <head>.");
}

// Configuración segura
const blotFormatterConfig = {
    overlay: {
        style: {
            border: '2px solid var(--color-primary)',
        }
    },
    align: {
        icons: {
            left: "<i class='fa-solid fa-align-left' style='align-content: center' ></i>",
            center: "<i class='fa-solid fa-align-center' style='align-content: center' ></i>",
            right: "<i class='fa-solid fa-align-right' style='align-content: center' ></i>"
        }
    }
    // Nota: Quitamos 'specs' temporalmente. La v4 detecta img/video automáticamente.
    // Si necesitas forzarlo, descomenta abajo SOLO si window.QuillBlotFormatter existe:
    /*
    specs: [
        (window.QuillBlotFormatter.default || window.QuillBlotFormatter).ImageSpec,
        (window.QuillBlotFormatter.default || window.QuillBlotFormatter).VideoSpec
    ]
    */
};  
  
 
  
  
  
/* --- ACTUALIZAR LA BARRA DE HERRAMIENTAS --- */
const fullToolbarOptions = [
  [{ 'font': Font.whitelist }],
  [{ 'size': Size.whitelist }], 
  // AGREGAMOS AQUÍ LA OPCIÓN DE INTERLINEADO
  [{ 'lineheight': ['1', '1.15', '1.5', '2', '2.5', '3'] }],
  ['bold', 'italic', 'underline', 'strike'],
  [{ 'color': [] }, { 'background': [] }],
  [{ 'script': 'sub'}, { 'script': 'super' }],
  [{ 'header': 1 }, { 'header': 2 }, 'blockquote', 'code-block'],
  [{ 'list': 'ordered'}, { 'list': 'bullet' }, { 'indent': '-1'}, { 'indent': '+1' }],
  [{ 'align': [] }],
  ['link', 'image', 'video'], // El botón de video ya existe aquí
  ['clean']
];

let mainQuillEditor;

// --- PASO 2: GESTOR DE FAVORITOS ACTUALIZADO ---
const FavManager = {
    get(type) { 
        return JSON.parse(localStorage.getItem(`quill_fav_${type}`) || '[]'); 
    },
    add(type, value) {
        let favs = this.get(type);
        if (!favs.includes(value)) {
            // Límite de 5 para colores, 3 para el resto
            const limit = (type === 'color' || type === 'background') ? 5 : 3;
            if (favs.length >= limit) favs.shift(); // Eliminar el más antiguo si está lleno
            favs.push(value);
            localStorage.setItem(`quill_fav_${type}`, JSON.stringify(favs));
        }
    },
    remove(type, value) {
        let favs = this.get(type);
        favs = favs.filter(f => f !== value);
        localStorage.setItem(`quill_fav_${type}`, JSON.stringify(favs));
    },
    has(type, value) { 
        return this.get(type).includes(value); 
    }
};
  
  
  
  

  
  
  

// --- FUNCIÓN DE INICIALIZACIÓN ---
// --- FUNCIÓN DE INICIALIZACIÓN ---
async function initializeNotes() { // <--- OJO: Ahora es ASYNC para poder esperar al render
    const addBtn = document.getElementById('add-note-btn');
    const dlBtn = document.getElementById('download-notes-btn');
    const ulBtn = document.getElementById('upload-notes-btn'); 
    
    // Inicializar el Editor Principal
// Inicializar el Editor Principal
    if (document.getElementById('editor-container') && !mainQuillEditor) {
        mainQuillEditor = new Quill('#editor-container', {
            theme: 'snow',
            placeholder: 'Escribe tu apunte maestro aquí...',
modules: { 
        toolbar: fullToolbarOptions,
        blotFormatter: blotFormatterConfig // <--- ASÍ
    }
        });
        
// Esta función corrige la alineación (asegúrate que esta función exista en tu código)
        if (typeof fixBlotFormatterAlignment === 'function') {
            fixBlotFormatterAlignment(mainQuillEditor);
        }
      
      
      
      
      
      
      
      
        // --- CORRECCIÓN BUG SCROLL IMAGEN ---
        // Cuando el usuario hace scroll en el editor, ocultamos la máscara de redimensión
        mainQuillEditor.root.addEventListener('scroll', function() {
            if (mainQuillEditor.getModule('blotFormatter')) {
                mainQuillEditor.getModule('blotFormatter').hide();
            }
        });
        
        setTimeout(() => { 
            enhanceQuillToolbar(mainQuillEditor); 
            mainQuillEditor.enable(true); 
        }, 50);
    }

    // --- CORRECCIÓN DEL BUSCADOR ---
    // 1. Esperamos a que se rendericen las notas de la DB
    await renderNotesAccordions(currentVideoId); 
    
    // 2. Inicializamos el sistema de búsqueda
    NotesSearchSystem.init();
    
    // 3. Forzamos la indexación INMEDIATA ahora que el HTML existe
    NotesSearchSystem.reIndex(); 

    if (addBtn) {
        addBtn.addEventListener('click', async () => {
            const targetId = currentVideoId; 
            if (!targetId || !player) return;
            
            const txtHTML = mainQuillEditor.root.innerHTML;
            const txtPlain = mainQuillEditor.getText().trim();
            const title = document.getElementById('note-input-title').value.trim();
            const timeStr = document.getElementById('note-input-time').value.trim();
            
            if (txtPlain.length === 0 && !txtHTML.includes('<img') && !txtHTML.includes('<iframe')) return;

            let s, ts;
            if (timeStr) {
                const p = parseTime(timeStr);
                if (p === null) { alert('Formato de tiempo inválido'); return; }
                s = p; ts = formatTime(p);
            } else {
                s = player.getCurrentTime(); 
                ts = formatTime(s);
            }
            
            await saveNote(targetId, { 
                id: Date.now(), 
                text: txtHTML, 
                title: title, 
                timestampSeconds: s, 
                timestamp: ts, 
                visible: true 
            });
            
            mainQuillEditor.setContents([]); 
            document.getElementById('note-input-title').value = '';
            document.getElementById('note-input-time').value = '';
            
            // Re-renderizar y Re-indexar tras agregar
            await renderNotesAccordions(targetId, true);
            NotesSearchSystem.reIndex();
        });
    }

    if (userPermissions.allowNoteButtons) {
        if (dlBtn) dlBtn.addEventListener('click', async () => {
            const allNotes = await db.getAll('notes');
            const allTitles = await db.getAll('titles');
            downloadNotesLogic(allNotes, allTitles, true);
        });
        if (ulBtn) ulBtn.addEventListener('click', openNoteManagerModal);
        initializeImportModalListeners();
    } else {
        if (dlBtn) dlBtn.remove();
        if (ulBtn) ulBtn.remove();
    }
}
  
  
  

  
/* =========================================================
   === GESTOR DEL LOADER (NUEVO) ===
   ========================================================= */
const LoaderUI = {
    overlay: document.getElementById('download-loader'),
    progressBar: document.getElementById('loader-progress-bar'),
    percentText: document.getElementById('loader-percent'),
    message: document.getElementById('loader-message'),
    interval: null,

    show(msg = "Procesando...") {
        this.message.textContent = msg;
        this.progressBar.style.width = '0%';
        this.percentText.textContent = '0%';
        this.overlay.classList.add('visible');
        
        // Simulación de progreso (Fake Progress)
        // Avanza rápido al principio, luego lento, hasta el 90%
        let progress = 0;
        this.interval = setInterval(() => {
            // Curva de progreso logarítmica simulada
            let increment = 0;
            if (progress < 30) increment = Math.random() * 5;
            else if (progress < 60) increment = Math.random() * 2;
            else if (progress < 90) increment = Math.random() * 0.5;
            
            progress += increment;
            if (progress > 95) progress = 95; // Esperar a que termine real
            
            this.update(Math.floor(progress));
        }, 200);
    },

    update(percent) {
        this.progressBar.style.width = `${percent}%`;
        this.percentText.textContent = `${percent}%`;
    },

    finish() {
        clearInterval(this.interval);
        this.update(100);
        setTimeout(() => {
            this.overlay.classList.remove('visible');
            this.update(0); // Reset
        }, 500); // Pequeña pausa para ver el 100%
    }
};  
  
  
  
// =========================================================
// === NUEVO SISTEMA DE DESCARGA E IMPORTACIÓN ===
// =========================================================

// =========================================================
// === SISTEMA DE DESCARGA E IMPORTACIÓN (VERSIÓN PRO) ===
// =========================================================


  
  
const DownloadManager = {
    // Preparar datos (Agrupa las notas por video y respeta el orden del sidebar)
    async prepareData(dataSource, onlyVisible) {
        const titleCache = await db.getAll('titles');
        const processedData = {};

        const getRealTitle = (vid, noteRef) => {
            if (fullCourseData[vid]) return fullCourseData[vid].title;
            if (titleCache[vid]) return titleCache[vid];
            if (noteRef && noteRef._tempVideoTitle) return noteRef._tempVideoTitle;
            return `Video ID: ${vid}`;
        };

        const processNotes = (vid, notes) => {
            if (!notes || notes.length === 0) return;
            const validNotes = onlyVisible ? notes.filter(n => n.visible !== false) : notes;
            if (validNotes.length === 0) return;
            const fullTitle = getRealTitle(vid, validNotes[0]);
            if (!processedData[fullTitle]) processedData[fullTitle] = { vid: vid, notes: [] };
            processedData[fullTitle].notes.push(...validNotes);
        };

        // Procesar según estructura del sidebar para mantener orden lógico
        sidebarStructure.forEach(t => t.subtopics.forEach(s => {
            if (dataSource[s.id]) processNotes(s.id, dataSource[s.id]);
        }));
        
        // Procesar videos que no estén en el sidebar (externos)
        const sidebarIds = new Set(sidebarStructure.flatMap(t => t.subtopics.map(s => s.id)));
        Object.keys(dataSource).forEach(vid => {
            if (!sidebarIds.has(vid)) processNotes(vid, dataSource[vid]);
        });
        
        return processedData;
    },

    // 1. WORD (.docx) - Estilos fieles usando TABLAS HTML
    async exportDOCX(dataSource, onlyVisible) {
        LoaderUI.show("Generando Word con estilos...");
        
        try {
            await new Promise(r => setTimeout(r, 100));        
            const data = await this.prepareData(dataSource, onlyVisible);
            const dateStr = new Date().toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            
            let htmlContent = `
                <!DOCTYPE html>
                <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                <head>
                    <meta charset='UTF-8'>
                    <style>
                        body { font-family: 'Calibri', Arial, sans-serif; }
                        img { max-width: 100%; height: auto; }
                    </style>
                </head>
                <body>
                    <div style="text-align: center; border-bottom: 2px solid #8a4dff; padding-bottom: 20px; margin-bottom: 30px;">
                        <h1 style="font-size: 24pt; color: #2D3142; margin: 0;">Apuntes AcaMedic</h1>
                        <p style="color: #666; font-size: 10pt;">Generado el ${dateStr}</p>
                    </div>
            `;

            Object.keys(data).forEach(title => {
                htmlContent += `
                    <div style="background-color: #8a4dff; color: white; padding: 10px 15px; margin-top: 20px; margin-bottom: 15px;">
                        <h2 style="margin: 0; font-size: 14pt;">${title}</h2>
                    </div>
                `;
                
                const group = data[title];
                group.notes.sort((a, b) => a.timestampSeconds - b.timestampSeconds).forEach((n, i) => {
                    const noteTitleHTML = n.title ? `<div style="font-weight: bold; color: #2D3142; font-size: 12pt; margin-bottom: 5px;">${n.title}</div>` : '';
                    
                    htmlContent += `
                        <table width="100%" style="width:100%; border-collapse: collapse; margin-bottom: 15px; background-color: #f9f9f9;">
                            <tr>
                                <td style="width: 5px; background-color: #8a4dff; padding: 0;"></td>
                                <td style="padding: 15px; border: 1px solid #e0e0e0; border-left: none;">
                                    <div style="margin-bottom: 10px;">
                                        <span style="color: #8a4dff; font-weight: bold; font-size: 10pt; background-color: #eee; padding: 3px 8px; border-radius: 4px;">
                                            ⏱ ${n.timestamp}
                                        </span>
                                    </div>
                                    ${noteTitleHTML}
                                    <div style="color: #444; font-size: 11pt; line-height: 1.5;">
                                        ${n.text}
                                    </div>
                                </td>
                            </tr>
                        </table>
                    `;
                });
                htmlContent += `<br>`;
            });

            htmlContent += `</body></html>`;
            
            const blob = htmlDocx.asBlob(htmlContent, {
                orientation: 'portrait',
                margins: { top: 720, right: 720, bottom: 720, left: 720 }
            });
            saveAs(blob, `Apuntes_AcaMedic_Word_${Date.now()}.docx`);
   
        } catch (e) {
            console.error(e);
            alert("Error al generar Word: " + e.message);
        } finally {
            LoaderUI.finish();
        }
    },

    // 2. PDF (TEXTO SELECCIONABLE) - Abre ventana de impresión nativa
    async exportPDF(dataSource, onlyVisible) {
        LoaderUI.show("Generando vista de impresión..."); 

        try {
            await new Promise(r => setTimeout(r, 500));
            const data = await this.prepareData(dataSource, onlyVisible);
            const dateStr = new Date().toLocaleDateString('es-ES', { day: 'numeric', month: 'long', year: 'numeric' });

            let htmlBody = '';

            Object.keys(data).forEach(title => {
                htmlBody += `
                    <div class="video-group">
                        <h2 class="video-title">${title}</h2>
                    </div>
                `;
                
                const group = data[title];
                group.notes.sort((a, b) => a.timestampSeconds - b.timestampSeconds).forEach(n => {
                    const noteTitleHTML = n.title ? `<div class="note-title">${n.title}</div>` : '';
                    
                    htmlBody += `
                        <div class="note-card">
                            <div class="note-meta">
                                <span class="timestamp-badge">⏱ ${n.timestamp}</span>
                            </div>
                            ${noteTitleHTML}
                            <div class="note-body ql-editor">
                                ${n.text}
                            </div>
                        </div>
                    `;
                });
            });

            const printWindow = window.open('', '_blank');
            
            if (!printWindow) {
                alert("Por favor, permite las ventanas emergentes (pop-ups) para generar el PDF.");
                return;
            }

            // NOTA: Aquí estaba el error. Se ha añadido la barra invertida en <\/script>
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Apuntes AcaMedic - ${dateStr}</title>
                    <meta charset="UTF-8">
                    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
                    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
                    <style>
                        body { font-family: 'Poppins', sans-serif; background-color: white; color: #2d3142; padding: 40px; max-width: 900px; margin: 0 auto; }
                        .print-header { text-align: center; border-bottom: 3px solid #8a4dff; padding-bottom: 20px; margin-bottom: 40px; }
                        .print-header h1 { color: #2c3e50; font-size: 28px; margin: 0; }
                        .print-header p { color: #7f8c8d; margin-top: 5px; }
                        .video-group { margin-top: 30px; margin-bottom: 20px; break-inside: avoid; }
                        .video-title { background: linear-gradient(90deg, #8a4dff 0%, #a875ff 100%); color: white; padding: 10px 20px; border-radius: 8px; font-size: 18px; margin: 0; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                        .note-card { border: 1px solid #e1e4e8; border-left: 5px solid #8a4dff; border-radius: 8px; padding: 15px 20px; margin-bottom: 15px; background-color: #ffffff; break-inside: avoid; }
                        .note-meta { margin-bottom: 10px; }
                        .timestamp-badge { background-color: #f0f2f7; color: #8a4dff; font-weight: 600; font-size: 12px; padding: 4px 10px; border-radius: 20px; -webkit-print-color-adjust: exact; print-color-adjust: exact; }
                        .note-title { font-weight: 700; color: #2c3e50; margin-bottom: 5px; font-size: 16px; }
                        .note-body { color: #444; font-size: 14px; line-height: 1.6; }
                        .note-body img { max-width: 100%; height: auto; display: block; margin: 10px 0; }
                        @media print { body { padding: 0; } .no-print { display: none; } ::-webkit-scrollbar { display: none; } }
                    </style>
                </head>
                <body>
                    <div class="print-header">
                        <h1>Apuntes AcaMedic</h1>
                        <p>Generado el ${dateStr}</p>
                    </div>
                    ${htmlBody}
                    <script>
                        window.onload = function() {
                            setTimeout(function() {
                                window.print();
                            }, 800);
                        };
                    <\/script>
                </body>
                </html>
            `);
            
            printWindow.document.close();

        } catch (e) {
            console.error(e);
            alert("Error al generar vista de impresión.");
        } finally {
            LoaderUI.finish();
        }
    },

    // 3. TEXTO (.txt)
    async exportTXT(dataSource, onlyVisible) {
        LoaderUI.show("Creando archivo de texto...");
        try {
            await new Promise(r => setTimeout(r, 500));
            const data = await this.prepareData(dataSource, onlyVisible);
            let textContent = "";
            Object.keys(data).forEach(title => {
                textContent += `--- ${title} ---\n`;
                data[title].notes.sort((a, b) => a.timestampSeconds - b.timestampSeconds).forEach((n, i) => {
                    const cleanText = n.text.replace(/<[^>]+>/g, '').trim(); 
                    const noteTitlePart = n.title ? `${n.title} - ` : '';
                    textContent += `${i + 1}. [${n.timestamp}] ${noteTitlePart}${cleanText}\n`;
                });
                textContent += `\n`;
            });
            const blob = new Blob([textContent], { type: "text/plain;charset=utf-8" });
            saveAs(blob, `Apuntes_AcaMedic_${Date.now()}.txt`);
        } finally {
            LoaderUI.finish();
        }
    },

    // 4. JSON (.json)
    async exportJSON(dataSource, onlyVisible) {
        LoaderUI.show("Empaquetando código...");
        try {
            await new Promise(r => setTimeout(r, 500));
            const data = await this.prepareData(dataSource, onlyVisible);
            const exportObj = { version: 2.0, timestamp: new Date().toISOString(), platform: 'AcaMedic', content: data };
            const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: "application/json" });
            saveAs(blob, `Apuntes_AcaMedic_${Date.now()}.json`);
        } finally {
            LoaderUI.finish();
        }
   }
};  
  
  
    
  
  

// --- FUNCIÓN DE INICIALIZACIÓN DE BOTONES (Soluciona el error de consola) ---
function setupDownloadDropdowns() {
    const buttons = [
        { id: 'download-notes-btn', source: 'db' },
        { id: 'download-all-import-btn', source: 'temp' }
    ];

    buttons.forEach(btnConfig => {
        const btn = document.getElementById(btnConfig.id);
        if (!btn) return;

        // IMPORTANTE: Clonar el botón para eliminar TODOS los event listeners antiguos
        // Esto soluciona el "ReferenceError: downloadNotesLogic is not defined"
        const newBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(newBtn, btn);

        // Volvemos a crear el wrapper alrededor del NUEVO botón
        const wrapper = document.createElement('div');
        wrapper.className = 'download-wrapper';
        newBtn.parentNode.insertBefore(wrapper, newBtn);
        wrapper.appendChild(newBtn);

        // Crear menú HTML
        const menu = document.createElement('div');
        menu.className = 'download-dropdown-menu';
        menu.innerHTML = `
            <button class="download-option" data-type="docx"><i class="fa-solid fa-file-word" style="color:#2b579a;"></i> Word (.docx)</button>
            <button class="download-option" data-type="pdf"><i class="fa-solid fa-file-pdf" style="color:#b30b00;"></i> PDF (.pdf)</button>
            <button class="download-option" data-type="txt"><i class="fa-solid fa-file-lines" style="color:#555;"></i> Texto (.txt)</button>
            <button class="download-option" data-type="json"><i class="fa-solid fa-code" style="color:#0f9d58;"></i> Código (.json)</button>
        `;
        wrapper.appendChild(menu);

        // Evento Toggle Menú
        newBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.download-dropdown-menu').forEach(m => {
                if(m !== menu) m.classList.remove('visible');
            });
            menu.classList.toggle('visible');
        });

        // Evento Click Opción
        menu.addEventListener('click', async (e) => {
            const option = e.target.closest('.download-option');
            if (!option) return;
            
            const type = option.dataset.type;
            let dataToExport, visibleOnly;

            if (btnConfig.source === 'db') {
                dataToExport = await db.getAll('notes');
                visibleOnly = true;
            } else {
                dataToExport = tempNoteSession; 
                visibleOnly = false;
            }

            switch(type) {
                case 'docx': await DownloadManager.exportDOCX(dataToExport, visibleOnly); break;
                case 'pdf': await DownloadManager.exportPDF(dataToExport, visibleOnly); break;
                case 'txt': await DownloadManager.exportTXT(dataToExport, visibleOnly); break;
                case 'json': await DownloadManager.exportJSON(dataToExport, visibleOnly); break;
            }
            menu.classList.remove('visible');
        });
    });

    // Cerrar menú al hacer click fuera
    document.addEventListener('click', () => {
        document.querySelectorAll('.download-dropdown-menu').forEach(m => m.classList.remove('visible'));
    });
}

// Llamar a esta función al iniciar
document.addEventListener('DOMContentLoaded', () => {
   // ... tus otros inits ...
   setupDownloadDropdowns();
});


// =========================================================
// === IMPORTACIÓN ACTUALIZADA (SOPORTE TXT Y JSON) ===
// =========================================================

async function handleFilesSelect(files) {
    if (!files || files.length === 0) return;
    const display = document.getElementById('file-list-display');

    for (const file of Array.from(files)) {
        // UI Tag
        const tag = document.createElement('div');
        tag.className = 'file-tag';
        tag.innerHTML = `<i class="fa-solid ${file.name.endsWith('.json') ? 'fa-code' : 'fa-file-lines'}"></i> ${file.name}`;
        display.appendChild(tag);

        const text = await new Promise(resolve => {
            const r = new FileReader();
            r.onload = e => resolve(e.target.result);
            r.readAsText(file);
        });

        if (file.name.endsWith('.json')) {
            // --- IMPORTACIÓN JSON (Estructura Exacta) ---
            try {
                const json = JSON.parse(text);
                // Soporte para estructura { version:..., content: {...} } o estructura raw
                const content = json.content || json; 
                
                Object.keys(content).forEach(titleKey => {
                    const group = content[titleKey]; // { vid: '...', notes: [] }
                    const vid = group.vid || getVidFromTitle(titleKey); // Fallback
                    
                    if (!tempNoteSession[vid]) tempNoteSession[vid] = [];
                    
                    group.notes.forEach(n => {
                        // Clonamos para evitar referencias
                        const noteCopy = { ...n };
                        // Importante: Marcar como NUEVA y PENDIENTE
                        noteCopy.id = Date.now() + Math.floor(Math.random() * 100000);
                        noteCopy.source = 'new';
                        noteCopy.isPending = true;
                        noteCopy._selected = true;
                        noteCopy._tempVideoTitle = titleKey; // Guardamos el título del grupo del JSON
                        
                        tempNoteSession[vid].push(noteCopy);
                    });
                });
            } catch (e) {
                console.error("Error importando JSON", e);
                alert("Error en el archivo JSON: " + file.name);
            }

        } else {
            // --- IMPORTACIÓN TXT (Regex Mejorado) ---
            const parsed = parseImportedText(text);
            Object.keys(parsed).forEach(vid => {
                if (!tempNoteSession[vid]) tempNoteSession[vid] = [];
                parsed[vid].forEach(n => {
                    n.id = Date.now() + Math.floor(Math.random() * 100000);
                    n.source = 'new';
                    n.isPending = true;
                    n._selected = true;
                    tempNoteSession[vid].push(n);
                });
            });
        }
    }

    await initImportSearch();
    await renderImportList();
    setTimeout(checkFileArrows, 100);
}

// Función auxiliar para recuperar ID si falta en el JSON (raro, pero útil)
function getVidFromTitle(title) {
    const entry = Object.entries(fullCourseData).find(([id, data]) => data.title === title);
    return entry ? entry[0] : 'ext_' + btoa(title).substring(0, 10);
}

// Mantén tu función parseImportedText pero asegúrate que coincida con el formato de exportación TXT
function parseImportedText(text) {
    const lines = text.split('\n');
    const result = {}; 
    let cvId = null;
    let cvTitle = null; 
    
    // Mapa inverso: Titulo -> ID (para asociar correctamente)
    const titleToIdMap = {};
    Object.keys(fullCourseData).forEach(id => titleToIdMap[fullCourseData[id].title.trim()] = id);

    lines.forEach(line => {
        line = line.trim();
        if (!line) return;

        // 1. Detectar Cabecera: --- Titulo ---
        const headerMatch = line.match(/^---\s+(.+)\s+---$/);
        if (headerMatch) {
            const titleFound = headerMatch[1].trim();
            cvTitle = titleFound; 
            // Buscar ID real
            cvId = titleToIdMap[titleFound];
            // Si no existe, crear ID temporal consistente
            if (!cvId) cvId = 'ext_' + btoa(titleFound).substring(0, 10);
            
            if (!result[cvId]) result[cvId] = [];
            return;
        }

        // 2. Detectar Nota: N. [MM:SS] Texto
        // Regex flexible: acepta que empiece con numero o no, pero requiere [00:00]
        const noteMatch = line.match(/^(?:\d+\.\s)?\[(\d+:\d+)\]\s(.*)$/);
        
        if (noteMatch && cvId) {
            const timeStr = noteMatch[1];
            let content = noteMatch[2];
            let noteTitle = '';

            // Separar titulo si existe "Titulo - Contenido"
            if (content.includes(' - ')) {
                const parts = content.split(' - ');
                // Heurística simple: si la primera parte es corta, es título
                if (parts[0].length < 100) { 
                    noteTitle = parts[0].trim(); 
                    content = parts.slice(1).join(' - ').trim(); 
                }
            }

            const secs = parseTime(timeStr);
            result[cvId].push({ 
                text: content, 
                title: noteTitle, 
                timestamp: timeStr, 
                timestampSeconds: secs, 
                _tempVideoTitle: cvTitle // Guardamos el título para que no se pierda
            });
        }
    });
    return result;
}  
  
  


  
  
  
  
  
  
  
  

async function saveNote(videoId, noteObj) {
    let notes = await db.get('notes', videoId, []);
    notes.push(noteObj);
    let titleToCache = null;
    if (fullCourseData[videoId]) titleToCache = fullCourseData[videoId].title;
    else if (noteObj._tempVideoTitle) titleToCache = noteObj._tempVideoTitle;
    if (titleToCache) await db.set('titles', videoId, titleToCache);
    await db.set('notes', videoId, notes);
}


  
  
  
  
  
  
  
function getNoteItemHTML(n, vid, isMainPageVideo, contextStr) {
    // Icono si es video externo
    const timeIcon = !isMainPageVideo && contextStr === 'main' 
        ? '<i class="fa-solid fa-up-right-from-square" style="font-size:0.7rem; margin-left:3px;"></i>' : '';
    
    // Clases para el seek
    const seekClass = contextStr === 'main' ? (isMainPageVideo ? 'main-seek' : 'quick-seek') : 'quick-modal-seek';

    // NUEVO BOTÓN AGREGADO AL FINAL DE 'note-item-actions-display'
    return `
    <div class="note-item" data-id="${n.id}" data-video-id="${vid}" data-context="${contextStr}">
        <div class="note-content-display">
            <div class="note-header">
                <span class="timestamp ${seekClass}" data-time="${n.timestampSeconds}" data-vid="${vid}" style="cursor:pointer; color: var(--color-primary); font-weight:600;">
                    ${n.timestamp} ${timeIcon}
                </span>
                <strong class="note-title">${n.title || ''}</strong>
            </div>
            <div class="note-text-display ql-editor" style="padding: 0; margin-top: 0.5rem; color: var(--color-text-secondary);">
                ${n.text}
            </div>
        </div>
        
        <div class="note-item-actions-display">
            <button class="open-popup-btn icon-action-btn" title="Abrir flotante" onclick="FloatingNoteSystem.open(${n.id}, '${vid}')">
                <i class="fa-solid fa-up-right-from-square"></i>
            </button>

            <button class="edit-note-btn icon-action-btn" title="Editar"><i class="fa-solid fa-pencil"></i></button>
            <button class="delete-note-btn icon-action-btn" title="Eliminar"><i class="fa-solid fa-trash"></i></button>
        </div>
        
        <div class="note-content-edit" style="display:none;">
            <div class="note-edit-grid">
                <input type="text" class="note-time-input edit-input-time" value="${n.timestamp}" placeholder="0:00">
                <input type="text" class="note-title-input edit-input-title" value="${n.title || ''}" placeholder="Título">
            </div>
            <div class="editing-quill-wrapper">
                <div class="editing-quill-container"></div> 
            </div>
        </div>
        <div class="note-item-actions-edit" style="display:none;">
            <button class="cancel-edit-btn button button-secondary">Cancelar</button>
            <button class="save-note-btn button button-primary">Guardar</button>
        </div>
    </div>`;
} 
  
  
  
  
  
  
  
  
  
  

function getPageContextHash() {
    if (!sidebarStructure) return 'default_ctx';
    const ids = sidebarStructure.flatMap(t => t.subtopics.map(s => s.id)).sort().join('');
    let hash = 0;
    for (let i = 0; i < ids.length; i++) {
        const char = ids.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
    }
    return 'ctx_' + Math.abs(hash);
}

async function getPageImportedNotes() {
    const ctx = getPageContextHash();
    try {
        const data = await db.get('imported', ctx, []);
        return data;
    } catch (e) { return []; }
}      

async function renderNotesAccordions(activeId, forceOpen = false) {
    const acc = document.getElementById('notes-list-accordion');
    if (!acc) return;

    // Obtener lista de notas importadas
    const importedMetaList = await getPageImportedNotes();
    const importedNoteIds = new Set(importedMetaList.map(item => item.id));
    const importedVideoIds = new Set(importedMetaList.map(item => item.vid));

    const openState = {};
    if (!forceOpen) {
        document.querySelectorAll('.note-accordion-item.open').forEach(i => openState[i.dataset.videoId] = true);
    } else {
        openState[activeId] = true;
    }
    
    acc.innerHTML = '';
    let hasNotes = false;
    const renderedVideoIds = new Set();

    const renderBlock = async (vid, title, isMain) => {
        let notes = await db.get('notes', vid, []);
        if (isMain) {
            notes = notes.filter(n => n.visible !== false); 
        } else {
            notes = notes.filter(n => importedNoteIds.has(n.id) && n.visible !== false);
        }

        if (notes.length > 0) {
            hasNotes = true;
            createAccordionItem(acc, vid, title, notes, openState[vid], isMain);
        }
    };

    // 1. Sidebar Principal
    for (const t of sidebarStructure) {
        for (const s of t.subtopics) {
            renderedVideoIds.add(s.id);
            await renderBlock(s.id, fullCourseData[s.id].title, true);
        }
    }

    // 2. Videos Externos
    const externalVids = [...importedVideoIds].filter(vid => !renderedVideoIds.has(vid));
    if (externalVids.length > 0) {
        const sep = document.createElement('div');
        sep.style.cssText = "padding: 1rem 0.5rem 0.5rem; color: var(--color-text-secondary); font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; border-top: 1px dashed var(--color-border); margin-top: 1rem;";
        sep.innerText = "Notas Importadas de Otras Páginas";
        acc.appendChild(sep);

        for (const vid of externalVids) {
            const title = await db.get('titles', vid, `Video ID: ${vid}`);
            await renderBlock(vid, title, false);
        }
    }

    if (!hasNotes) acc.innerHTML = '<p style="color:#8a8f9d;text-align:center;padding:2rem;">Sin notas.</p>';
    
    // --- IMPORTANTE: Lógica de indexado integrada aquí mismo ---
    if (typeof NotesSearchSystem !== 'undefined') {
        NotesSearchSystem.init(); 
        NotesSearchSystem.reIndex();
    }
}
  
  
  
  
  
  

function createAccordionItem(container, vid, title, notes, isOpen, isMainPageVideo) {
    const div = document.createElement('div');
    div.className = `note-accordion-item ${isOpen ? 'open' : ''}`;
    div.dataset.videoId = vid;
    
    const notesHtml = notes.sort((a,b)=>a.timestampSeconds-b.timestampSeconds)
        .map(n => getNoteItemHTML(n, vid, isMainPageVideo, 'main'))
        .join('');

    div.innerHTML = `
        <div class="note-accordion-header">
            <span>${title} (${notes.length})</span>
            <i class="fa-solid fa-chevron-down"></i>
        </div>
        <div class="note-accordion-content">
            <div class="notes-list-inner">${notesHtml}</div>
        </div>`;
    
    if (!isMainPageVideo) {
        div.querySelector('.note-accordion-header').addEventListener('dblclick', async (e) => {
             e.stopPropagation();
             if (!isVideoAccessAllowed(vid)) {
                 showGlobalTooltip("<i class='fa-solid fa-lock' style='color:#d69e2e'></i> <b>Video Bloqueado</b>", e);
                 return;
             }
             openQuickViewModal(vid);
        });
    }
    container.appendChild(div);
}   

async function openQuickViewModal(videoId, startTime = 0) {
    if (!isVideoAccessAllowed(videoId)) return; 
    currentQuickVideoId = videoId; 
    const modal = document.getElementById('quick-view-backdrop');
    const title = await db.get('titles', videoId, 'Video Externo');
    document.getElementById('quick-view-title').innerHTML = `<i class="fa-brands fa-youtube" style="color:red;"></i> ${title}`;
    modal.classList.add('visible');
    if (quickPlayer) { quickPlayer.loadVideoById({videoId: videoId, startSeconds: startTime}); }
    else { quickPlayer = new YT.Player('quick-player-container', { height: '100%', width: '100%', videoId: videoId, playerVars: { 'autoplay': 1, 'start': startTime }, }); }
    await renderQuickModalNotes();
}

async function renderQuickModalNotes() {
    const list = document.getElementById('quick-notes-list');
    const notes = await db.get('notes', currentQuickVideoId, []);
    list.innerHTML = notes.sort((a,b)=>a.timestampSeconds-b.timestampSeconds)
        .map(n => getNoteItemHTML(n, currentQuickVideoId, false, 'quick'))
        .join('');
}

document.getElementById('quick-add-btn').addEventListener('click', async () => {
    if (!currentQuickVideoId || !quickPlayer) return;
    const txt = document.getElementById('quick-note-text').value.trim();
    if (!txt) return;
    let s = quickPlayer.getCurrentTime();
    let ts = formatTime(s);
    const timeStr = document.getElementById('quick-note-time').value.trim();
    if(timeStr) { const p = parseTime(timeStr); if(p!==null) {s=p; ts=formatTime(p);} }
    await saveNote(currentQuickVideoId, { id: Date.now(), text: txt, title: document.getElementById('quick-note-title').value.trim(), timestampSeconds: s, timestamp: ts, visible: true });
    document.getElementById('quick-note-text').value = '';
    document.getElementById('quick-note-title').value = '';
    document.getElementById('quick-note-time').value = '';
    await renderQuickModalNotes();
    await renderNotesAccordions(currentVideoId);
});

document.getElementById('close-quick-view').addEventListener('click', () => {
    document.getElementById('quick-view-backdrop').classList.remove('visible');
    if (quickPlayer) quickPlayer.stopVideo();
});


  
  
  
  
  
// =========================================================
// === LISTENER GLOBAL OPTIMIZADO (LAZY LOADING QUILL) ===
// =========================================================
// Variable para almacenar la instancia activa de Quill en modo edición
let activeEditingQuill = null;

document.addEventListener('click', async (e) => {
    const target = e.target;

    // --- 1. ACORDEÓN (Optimizado) ---
    const accHeader = target.closest('.note-accordion-header');
    if (accHeader) { 
        const item = accHeader.parentElement;
        // Cerrar otros si quieres ahorrar recursos (opcional, aquí lo dejo estándar)
        item.classList.toggle('open'); 
        return; 
    }

    // --- 2. TIMESTAMP (Seek) ---
    const seekBtn = target.closest('.timestamp');
    if (seekBtn) {
        const vid = seekBtn.dataset.vid;
        const time = parseFloat(seekBtn.dataset.time);
        
        if (!isVideoAccessAllowed(vid)) { 
            e.preventDefault(); e.stopPropagation(); 
            showGlobalTooltip("<i class='fa-solid fa-lock' style='color:#d69e2e'></i> <b>Contenido Bloqueado</b>", e); 
            return; 
        }

        if (seekBtn.classList.contains('main-seek')) { 
            if (vid && vid !== currentVideoId) {
                // Cambio de video optimizado
                currentVideoId = vid;
                const newUrl = `${window.location.pathname}?video=${currentVideoId}`;
                if (fullCourseData[currentVideoId]) window.history.pushState({ videoId: currentVideoId }, fullCourseData[currentVideoId].title, newUrl);
                await loadPageContent(currentVideoId);
                updateActiveSidebarItem(currentVideoId);
                await renderNotesAccordions(currentVideoId, true);
                if(player && player.loadVideoById) player.loadVideoById({videoId: currentVideoId, startSeconds: time});
            } else { 
                if(player) player.seekTo(time, true); 
                // Scroll suave hacia el video
                document.querySelector('.video-section').scrollIntoView({ behavior: 'smooth' });
            }
        }
        else if (seekBtn.classList.contains('quick-seek')) openQuickViewModal(vid, time); 
        else if (seekBtn.classList.contains('quick-modal-seek')) { if(quickPlayer) quickPlayer.seekTo(time, true); }
        return;
    }

    // --- 3. LÓGICA DE NOTAS ---
    const noteItem = target.closest('.note-item');
    if (!noteItem) return;

    const vid = noteItem.dataset.videoId;
    const nid = parseInt(noteItem.dataset.id);
    const context = noteItem.dataset.context; // 'main' o 'quick'
    
    // --- ACCIÓN: EDITAR (Full Fix) ---
// --- ACCIÓN: EDITAR (CORREGIDO Y OPTIMIZADO) ---
    if (target.closest('.edit-note-btn')) {
        // 1. LIMPIEZA TOTAL: Cerrar cualquier otro editor abierto previamente
        document.querySelectorAll('.note-item.is-editing').forEach(el => {
            el.classList.remove('is-editing');
            const oldWrapper = el.querySelector('.editing-quill-wrapper');
            // AQUÍ ESTÁ LA CLAVE: Reiniciamos el HTML a su estado original limpio
            if (oldWrapper) oldWrapper.innerHTML = '<div class="editing-quill-container"></div>';
        });

        // Limpiar clases de overflow en acordeones previos
        document.querySelectorAll('.note-accordion-item.allow-overflow').forEach(el => el.classList.remove('allow-overflow'));

        // 2. Activar modo edición en ESTA nota
        noteItem.classList.add('is-editing');

        // 3. Permitir overflow para que los menús se vean (aunque usamos fixed, esto ayuda al layout)
        const parentAccordionItem = noteItem.closest('.note-accordion-item');
        const parentAccordionContent = noteItem.closest('.note-accordion-content');
        if(parentAccordionItem) parentAccordionItem.classList.add('allow-overflow');
        if(parentAccordionContent) parentAccordionContent.classList.add('allow-overflow');

        // 4. INICIALIZAR QUILL
            // 4. INICIALIZAR QUILL (MODIFICADO CON RESIZE)
            const quillContainer = noteItem.querySelector('.editing-quill-container');
            const notesArr = await db.get('notes', vid, []);
            const noteObj = notesArr.find(n => n.id === nid);

if(noteObj && quillContainer) {
                // 1. PRIMERO: Creamos la instancia VACÍA
                activeEditingQuill = new Quill(quillContainer, {
                    theme: 'snow',
modules: { 
        toolbar: fullToolbarOptions,
        blotFormatter: blotFormatterConfig // <--- ASÍ
    }
                });

                // 2. SEGUNDO: Inyectamos el contenido HTML DIRECTAMENTE en el root de Quill
                // Esto fuerza a Quill a reconocer los estilos inline (line-height, text-align)
                activeEditingQuill.root.innerHTML = noteObj.text; 
                
                fixBlotFormatterAlignment(activeEditingQuill); // <--- AÑADE ESTA LÍNEA AQUÍ  
  
  
  
  
  
  
                // 3. FIX CRÍTICO SCROLL IMAGEN: Ocultar manejadores al hacer scroll
                activeEditingQuill.root.addEventListener('scroll', function() {
                    if (activeEditingQuill.getModule('blotFormatter')) {
                        activeEditingQuill.getModule('blotFormatter').hide();
                    }
                });

                enhanceQuillToolbar(activeEditingQuill);
            }
    }

    // --- ACCIÓN: CANCELAR (CORREGIDO) ---
    if (target.closest('.cancel-edit-btn')) {
        noteItem.classList.remove('is-editing');
        
        // 1. Quitar permisos de overflow
        const parentAccordionItem = noteItem.closest('.note-accordion-item');
        if(parentAccordionItem) parentAccordionItem.classList.remove('allow-overflow');
        
        // 2. DESTRUCCIÓN TOTAL DEL EDITOR
        // No solo vaciamos el texto, reiniciamos la estructura DOM
        // para eliminar las barras de herramientas generadas por Quill.
        const wrapper = noteItem.querySelector('.editing-quill-wrapper');
        if (wrapper) {
            wrapper.innerHTML = '<div class="editing-quill-container"></div>';
        }

        activeEditingQuill = null;
    }
    
    // --- ACCIÓN: GUARDAR ---
// --- ACCIÓN: GUARDAR (EN EL ACORDEÓN) ---
    if (target.closest('.save-note-btn')) {
        let notesArr = await db.get('notes', vid, []);
        const idx = notesArr.findIndex(n => n.id === nid);
        
        if (idx !== -1) {
            const newT = noteItem.querySelector('.edit-input-time').value;
            const newTi = noteItem.querySelector('.edit-input-title').value;
            
            // Obtener HTML desde la instancia activa
            let newTx = '';
            if (activeEditingQuill) {
                newTx = activeEditingQuill.root.innerHTML;
            } else {
                newTx = notesArr[idx].text; // Fallback
            }

            const ps = parseTime(newT);
            const hasContent = newTx.replace(/<[^>]*>/g, '').trim().length > 0 || newTx.includes('<img') || newTx.includes('<iframe');

            if (ps !== null && hasContent) {
                // Objeto actualizado
                const updatedNote = { 
                    ...notesArr[idx], 
                    title: newTi, 
                    text: newTx, 
                    timestamp: formatTime(ps), 
                    timestampSeconds: ps 
                };

                // 1. Guardar en DB
                notesArr[idx] = updatedNote;
                await db.set('notes', vid, notesArr);
                
                // 2. Limpiar UI Editor
                activeEditingQuill = null;
                noteItem.classList.remove('is-editing');
                const wrapper = noteItem.querySelector('.editing-quill-wrapper');
                if (wrapper) wrapper.innerHTML = '<div class="editing-quill-container"></div>';
                
                const parentAccordionItem = noteItem.closest('.note-accordion-item');
                if(parentAccordionItem) parentAccordionItem.classList.remove('allow-overflow');

                // 3. SINCRONIZACIÓN MÁGICA: Si hay un popup abierto para esta nota, actualízalo
                // (Reflejo Lista -> Popup)
                if (typeof FloatingNoteSystem !== 'undefined') {
                    FloatingNoteSystem.refreshView(nid, updatedNote);
                }

                // 4. Re-renderizar listas
                if (context === 'main') {
                    await renderNotesAccordions(currentVideoId);
                } else {
                    await renderQuickModalNotes();
                    await renderNotesAccordions(currentVideoId);
                }
            } else {
                alert("La nota no puede estar vacía o el tiempo es inválido.");
            }
        }
    }

    // --- ACCIÓN: ELIMINAR (Igual que antes) ---
    if (target.closest('.delete-note-btn')) {
        if(confirm('¿Eliminar definitivamente?')) {
            let notesArr = await db.get('notes', vid, []);
            const newNotes = notesArr.filter(n => n.id !== nid);
            await db.set('notes', vid, newNotes);
            context === 'main' ? await renderNotesAccordions(currentVideoId) : (await renderQuickModalNotes(), await renderNotesAccordions(currentVideoId));
        }
    }
});
  
  
  
  
  
  
  
  
  

// =========================================================
// === FUNCIONES AUXILIARES DE BÚSQUEDA INTELIGENTE ===
// =========================================================

// Genera una Expresión Regular que ignora tildes y diacríticos
function getSmartRegex(query) {
    if (!query) return null;
    const escaped = query.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    
    // Mapeo de vocales y caracteres especiales
    const map = {
        'a': '[aáàäâ]', 
        'á': '[aáàäâ]',
        'e': '[eéèëê]', 
        'é': '[eéèëê]',
        'i': '[iíìïî]', 
        'í': '[iíìïî]',
        'o': '[oóòöô]', 
        'ó': '[oóòöô]',
        'u': '[uúùüû]',
        'ú': '[uúùüû]',
        'n': '[nñ]',
        'A': '[AÁÀÄÂ]', 
        'Á': '[AÁÀÄÂ]', 
        'E': '[EÉÈËÊ]', 
        'É': '[EÉÈËÊ]',
        'I': '[IÍÌÏÎ]', 
        'Í': '[IÍÌÏÎ]',
        'O': '[OÓÒÖÔ]', 
        'Ó': '[OÓÒÖÔ]',
        'U': '[UÚÙÜÛ]',
        'Ú': '[UÚÙÜÛ]',
        'N': '[NÑ]'
    };

    let regexStr = '';
    for (let char of escaped) {
        regexStr += map[char] || char;
    }
    
    return new RegExp(`(${regexStr})`, 'gi');
}

// Resalta texto en HTML sin romper etiquetas
function highlightTextSmart(htmlContent, query) {
    if (!query || query.length < 2) return htmlContent;
    const regex = getSmartRegex(query);
    if (!regex) return htmlContent;

    // Reemplaza texto que NO esté dentro de etiquetas HTML (<...>)
    return htmlContent.replace(new RegExp(`(?!<[^>]*?>)(${regex.source})(?![^<]*?>)`, 'gi'), 
        '<span class="search-highlight" style="background:#ffeeba; color:#856404; padding:0 2px; border-radius:2px;">$1</span>');
}
  
  
  
  
  
  
  

// =========================================================
// === 8. GESTOR DE IMPORTACIÓN (MODAL) ===
// =========================================================

async function openNoteManagerModal() {
    const modal = document.getElementById('import-modal-backdrop');
    // Carga necesaria para el Gestor (búsqueda global)
    const existingNotes = await db.getAll('notes');
    const titleCache = await db.getAll('titles');

    Object.keys(fullCourseData).forEach(id => titleCache[id] = fullCourseData[id].title);
    
    tempNoteSession = JSON.parse(JSON.stringify(existingNotes));
    
    const nativeIds = new Set(sidebarStructure.flatMap(t => t.subtopics.map(s => s.id)));
    // Obtenemos metadatos de importación actual
    const importedMetaList = await getPageImportedNotes();
    const allowedNoteIds = new Set(importedMetaList.map(item => item.id));

    Object.keys(tempNoteSession).forEach(vid => {
        const isNativeVideo = nativeIds.has(vid);
        tempNoteSession[vid].forEach(n => {
            n.source = 'existing';
            n.isPending = false; 
            if (isNativeVideo) {
                n._selected = (n.visible !== false); 
            } else {
                n._selected = allowedNoteIds.has(n.id);
            }
        });
    });

    document.getElementById('file-list-display').innerHTML = '';
    document.getElementById('modal-file-input').value = '';
    document.getElementById('import-search-input').value = ''; 
    setTimeout(() => { initializeDraggable(document.getElementById('file-list-display')); checkFileArrows(); }, 100);
    await initImportSearch(); 
    await renderImportList(); 
    modal.classList.add('visible');
}      





function checkFileArrows() {
    const list = document.getElementById('file-list-display');
    const l = document.getElementById('file-arrow-left');
    const r = document.getElementById('file-arrow-right');
    if (!list || !l || !r) return;
    if (list.scrollWidth > list.clientWidth) {
        l.style.display = list.scrollLeft > 1 ? 'grid' : 'none';
        r.style.display = list.scrollLeft < list.scrollWidth - list.clientWidth - 1 ? 'grid' : 'none';
    } else { l.style.display = 'none'; r.style.display = 'none'; }
}

async function initImportSearch() {
    const flatNotes = [];
    const titleCache = await db.getAll('titles'); 
    Object.keys(tempNoteSession).forEach(vid => {
        const vTitle = fullCourseData[vid]?.title || titleCache[vid] || tempNoteSession[vid][0]?._tempVideoTitle || vid;
        tempNoteSession[vid].forEach(n => { flatNotes.push({ ...n, vid: vid, videoTitle: vTitle }); });
    });
    const options = { keys: [{ name: 'text', weight: 0.6 }, { name: 'title', weight: 0.3 }, { name: 'videoTitle', weight: 0.1 }], threshold: 0.4, ignoreLocation: true };
    noteImportFuse = new Fuse(flatNotes, options);
}

// =========================================================
// === RENDERIZADO DE LISTA DE IMPORTACIÓN (COMPLETO) ===
// =========================================================

async function renderImportList() {
    const container = document.getElementById('import-list-container');
    const searchTerm = document.getElementById('import-search-input').value.trim();
    const titleCache = await db.getAll('titles');
    
    container.innerHTML = '';
    let totalActive = 0;
    
    // --- 1. LÓGICA DE BÚSQUEDA Y ORDENAMIENTO ---
    let searchResultsMap = null; // Mapa: vid -> [id1, id2...] ordenados por relevancia

    if (searchTerm.length > 1) {
        // Aseguramos que Fuse esté inicializado
        if (!noteImportFuse) await initImportSearch();
        
        // Buscamos usando Fuse (maneja errores ortográficos leves)
        const results = noteImportFuse.search(searchTerm);
        
        searchResultsMap = {};
        results.forEach(r => {
            if (!searchResultsMap[r.item.vid]) searchResultsMap[r.item.vid] = [];
            searchResultsMap[r.item.vid].push(r.item.id);
        });
    }

    // --- 2. FUNCIÓN PARA RENDERIZAR GRUPOS DE VIDEOS ---
    const renderGroup = (vid, notes, isCurrentPage) => {
        // A. Filtrar notas a mostrar
        let filteredNotes = [];
        
        if (searchResultsMap) {
            // Si hay búsqueda: Usamos el orden y filtro de Fuse
            const orderedIds = searchResultsMap[vid];
            if (!orderedIds) return; // Si no hay coincidencias en este video, no mostrar nada
            
            // Reconstruir array en orden de relevancia
            orderedIds.forEach(id => {
                const note = notes.find(n => n.id === id);
                if (note) filteredNotes.push(note);
            });
        } else {
            // Sin búsqueda: Mostrar todas las del video
            filteredNotes = notes;
        }

        if (filteredNotes.length === 0) return;

        // B. Crear Contenedor del Grupo
        const group = document.createElement('div');
        group.className = 'import-video-group';
        
        // Título del Video
        const displayTitle = fullCourseData[vid]?.title || titleCache[vid] || notes[0]?._tempVideoTitle || `Video ID: ${vid}`;
        const headerStyle = isCurrentPage ? '' : 'background: #e2e8f0; color: #4a5568; font-style: italic;';
        
        // Resaltar título del grupo si coincide
        let highlightedGroupTitle = displayTitle;
        if (searchTerm.length > 1) highlightedGroupTitle = highlightTextSmart(displayTitle, searchTerm);

        group.innerHTML = `<div class="import-video-header" style="${headerStyle}">${highlightedGroupTitle} (${filteredNotes.length})</div>`;
        
        // C. Renderizar Notas Individuales
        filteredNotes.forEach(n => {
            // Contar activas para el resumen del footer
            if (!n.isPending && n._selected) totalActive++;
            
            const row = document.createElement('div');
            // Clase para ocultar visualmente notas no seleccionadas (opaco)
            const hiddenClass = (!n.isPending && !n._selected) ? 'is-hidden-note' : '';
            row.className = `import-note-item ${n._editing ? 'is-editing' : ''} ${hiddenClass}`;

            // Preparar textos resaltados (para Modo Vista)
            let displayTitleNote = n.title ? n.title : '';
            let displayTextNote = n.text;

            if (searchTerm.length > 1 && !n._editing) {
                if (displayTitleNote) displayTitleNote = highlightTextSmart(displayTitleNote, searchTerm);
                displayTextNote = highlightTextSmart(displayTextNote, searchTerm);
            }

            // --- ESCENARIO 1: MODO EDICIÓN ---
            if (n._editing) {
                // Generar opciones para mover nota de video
                const videoOptions = [
                    ...sidebarStructure.flatMap(t => t.subtopics).map(s => `<option value="${s.id}">${s.title}</option>`), 
                    (!fullCourseData[vid] ? `<option value="${vid}">${displayTitle}</option>` : '')
                ].join('');
                
                row.innerHTML = `
                    <div class="import-edit-form" style="width:100%; padding: 10px;">
                        <div class="import-edit-row">
                            <input type="text" class="note-time-input" id="edit-time-${n.id}" value="${n.timestamp}" placeholder="Tiempo">
                            <input type="text" class="note-title-input" id="edit-title-${n.id}" value="${n.title || ''}" placeholder="Título">
                        </div>
                        
                        <div class="import-quill-container" style="margin-top:10px;">
                            <div class="import-quill-editor-container" id="edit-editor-${n.id}" style="min-height:150px; background:white;"></div>
                        </div>

                        <div style="display:flex; flex-direction: column; gap: 10px; margin-top:10px;">
                            <label style="font-size:0.8rem; display:flex; gap:5px; flex-direction: column;">
                                Mover a: <select class="video-selector" id="edit-video-${n.id}" style="margin:0;">${videoOptions}</select>
                            </label>
                            <div class="import-edit-actions" style="border:none; padding:0; display:flex; justify-content:flex-end; gap:5px;">
                                <button class="button button-secondary cancel-import-edit" data-vid="${vid}" data-id="${n.id}">Cancelar</button>
                                <button class="button button-primary save-import-edit" data-vid="${vid}" data-id="${n.id}">Guardar</button>
                            </div>
                        </div>
                    </div>`;
                
                // Inicializar Quill después de insertar el HTML
                setTimeout(() => { 
                    const select = document.getElementById(`edit-video-${n.id}`); 
                    if(select) select.value = vid; 
                    
                    const editorDiv = document.getElementById(`edit-editor-${n.id}`);
                    if(editorDiv && !editorDiv._quill) {
                        const q = new Quill(editorDiv, {
                            theme: 'snow',
modules: { 
        toolbar: fullToolbarOptions,
        blotFormatter: blotFormatterConfig // <--- ASÍ
    }
                        });
                        q.root.innerHTML = n.text; 
                      
                        editorDiv._quill = q; 
                        // Aplicar mejoras de toolbar (scroll, color picker, etc.)
                      
                      fixBlotFormatterAlignment(q); // <--- AÑADE ESTA LÍNEA AQUÍ
                        enhanceQuillToolbar(q); 
                    }
                }, 0);

            } else {
                // --- ESCENARIO 2: MODO VISTA (DISEÑO TARJETA) ---
                
                const titleHtml = displayTitleNote ? `<div class="import-note-title-badge">${displayTitleNote}:</div>` : '';

                // Estructura HTML Nueva: Flex Column (Header Arriba, Content Abajo)
                const controlsHtml = `
                <div class="import-view-mode">
                    
                    <div class="import-card-header">
                        <input type="checkbox" class="import-check" data-vid="${vid}" data-id="${n.id}" ${n._selected ? 'checked' : ''} title="Seleccionar/Deseleccionar">
                        
                        <div class="import-actions-cell">
                            <button class="import-btn-icon edit" title="Editar" data-vid="${vid}" data-id="${n.id}"><i class="fa-solid fa-pencil"></i></button>
                            <button class="import-btn-icon delete" title="Eliminar" data-vid="${vid}" data-id="${n.id}"><i class="fa-solid fa-trash"></i></button>
                        </div>
                    </div>

                    <div class="import-note-content">
                        <div style="display:flex; align-items:center; gap:5px; margin-bottom:5px;">
                            <small style="font-weight:600; color:var(--color-primary);">${n.timestamp}</small> 
                            ${n.source==='new' ? '<span class="badge-new">NUEVA</span>' : ''}
                        </div>
                        
                        <div style="margin-top: 4px;">
                            ${titleHtml}
                            <div class="ql-editor" style="padding:0;">${displayTextNote}</div>
                        </div>
                    </div>

                </div>`;

                if (n.isPending) {
                    // Diseño Especial para Notas Pendientes (Fondo amarillento)
                     row.innerHTML = `
                    <div class="import-view-mode" style="background: #fffbf0; border: 1px solid #fbd38d;">
                        <div class="import-card-header">
                            <small style="color:orange; font-weight:bold; display:flex; align-items:center; gap:5px;">
                                <i class="fa-solid fa-circle-exclamation"></i> Pendiente
                            </small>
                            <div class="import-pending-actions">
                                <button class="btn-accept-import" data-vid="${vid}" data-id="${n.id}" title="Aceptar"><i class="fa-solid fa-check"></i></button>
                                <button class="btn-reject-import" data-vid="${vid}" data-id="${n.id}" title="Rechazar"><i class="fa-solid fa-xmark"></i></button>
                            </div>
                        </div>
                        
                        <div class="import-note-content">
                            <small style="color:#666; margin-bottom:5px; display:block;">[${n.timestamp}]</small>
                            ${titleHtml}
                            <div class="ql-editor" style="color:#555; padding:0;">${displayTextNote}</div>
                        </div>
                    </div>`;
                } else {
                    // Diseño Normal
                    row.innerHTML = controlsHtml;
                }
            }
            group.appendChild(row);
        });
        container.appendChild(group);
    };

    // --- 3. ORGANIZACIÓN GLOBAL DE LA LISTA ---
    const currentVidIds = new Set(Object.keys(fullCourseData));
    const allVids = Object.keys(tempNoteSession);
    
    // Separar videos de la página actual vs otros videos
    const pageVids = allVids.filter(id => currentVidIds.has(id));
    const otherVids = allVids.filter(id => !currentVidIds.has(id));

    // Renderizar Sección: Página Actual
    if (pageVids.length > 0) {
        const h = document.createElement('h5'); 
        h.style.cssText = "padding:1rem; color:var(--color-primary); border-bottom:1px solid #eee; margin-top:0;"; 
        h.innerHTML = '<i class="fa-solid fa-location-dot"></i> Notas Página Actual'; 
        container.appendChild(h); 
        pageVids.forEach(v => renderGroup(v, tempNoteSession[v], true)); 
    }
    
    // Renderizar Sección: Otras Notas
    if (otherVids.length > 0) { 
        const h = document.createElement('h5'); 
        h.style.cssText = "padding:1rem; color:var(--color-text-secondary); border-bottom:1px solid #eee; margin-top:1rem;"; 
        h.innerHTML = '<i class="fa-solid fa-layer-group"></i> Otras Notas Importadas'; 
        container.appendChild(h); 
        otherVids.forEach(v => renderGroup(v, tempNoteSession[v], false)); 
    }
    
    // Mensaje de estado vacío
    if (container.children.length === 0) {
        container.innerHTML = `
            <div style="padding:3rem; text-align:center; color:#999;">
                <i class="fa-solid fa-magnifying-glass" style="font-size:2rem; margin-bottom:10px;"></i>
                <p>No se encontraron notas que coincidan.</p>
            </div>`;
    }

    // Actualizar contador del footer
    document.getElementById('import-summary-text').textContent = `Activas: ${totalActive}`;
}

function initializeImportModalListeners() {
    document.getElementById('trigger-file-select').addEventListener('click', () => document.getElementById('modal-file-input').click());
    document.getElementById('modal-file-input').addEventListener('change', async (e) => await handleFilesSelect(e.target.files));
    const fList = document.getElementById('file-list-display');
    document.getElementById('file-arrow-left').addEventListener('click', () => fList.scrollLeft -= 150);
    document.getElementById('file-arrow-right').addEventListener('click', () => fList.scrollLeft += 150);
    fList.addEventListener('scroll', checkFileArrows);
    window.addEventListener('resize', checkFileArrows);
    document.getElementById('import-search-input').addEventListener('input', async () => await renderImportList());
    document.getElementById('download-all-import-btn').addEventListener('click', async () => { const cache = await db.getAll('titles'); downloadNotesLogic(tempNoteSession, cache, false); });
    
    // LOGICA CORREGIDA DEL BOTÓN GUARDAR
// REEMPLAZA el listener de 'save-import-btn' dentro de initializeImportModalListeners()
document.getElementById('save-import-btn').addEventListener('click', async () => {
    const nativeIds = new Set(sidebarStructure.flatMap(t => t.subtopics.map(s => s.id)));
    const newImportedMetaList = []; 

    // 1. Recorrer TODAS las claves de la sesión temporal
    for (const vid of Object.keys(tempNoteSession)) {
        // Filtrar notas: que no estén pendientes de aprobación y que estén marcadas para guardar
        // IMPORTANTE: Al mover una nota, esta desaparece del array 'vid' original en tempNoteSession
        // y aparece en el nuevo 'vid'. Al sobrescribir la DB aquí, se corrige el origen y destino.
        const validNotes = tempNoteSession[vid].filter(n => !n.isPending);
        
        // Si hay notas válidas, guardamos/actualizamos
        if (validNotes.length > 0) {
            // Asegurar título en caché
            if (fullCourseData[vid]) await db.set('titles', vid, fullCourseData[vid].title);
            else if (validNotes[0]._tempVideoTitle) await db.set('titles', vid, validNotes[0]._tempVideoTitle);

            const finalNotes = validNotes.map(n => {
                // Si es un video externo (no nativo del curso), lo agregamos a la lista de importados
                if (!nativeIds.has(vid) && n._selected) {
                    newImportedMetaList.push({ id: n.id, vid: vid });
                }
                // Limpiamos propiedades temporales antes de guardar en DB
                return { 
                    id: n.id, 
                    text: n.text, 
                    title: n.title, 
                    timestamp: n.timestamp, 
                    timestampSeconds: n.timestampSeconds, 
                    visible: n._selected 
                };
            });
            
            // SOBRESCRIBIR LA BASE DE DATOS PARA ESTE VIDEO
            await db.set('notes', vid, finalNotes);
            
        } else {
            // CASO CRÍTICO: Si después de filtrar no quedan notas (ej: se borraron todas o se movieron todas)
            // Debemos actualizar la DB con un array vacío para que desaparezcan visualmente
            await db.set('notes', vid, []);
        }
    }

    // Actualizar índice de notas importadas
    const ctx = getPageContextHash();
    await db.set('imported', ctx, newImportedMetaList);

    document.getElementById('import-modal-backdrop').classList.remove('visible');
    
    // Forzar re-renderizado del acordeón principal para reflejar cambios
    await renderNotesAccordions(currentVideoId, true);
    
    alert('Notas guardadas y sincronizadas correctamente.');
});

    document.getElementById('close-import-modal').addEventListener('click', () => document.getElementById('import-modal-backdrop').classList.remove('visible'));
    document.getElementById('import-list-container').addEventListener('click', async (e) => {
        const t = e.target.closest('button') || e.target;
        if (t.classList.contains('btn-accept-import')) { const vid = t.dataset.vid; const id = parseInt(t.dataset.id); const n = tempNoteSession[vid].find(x => x.id === id); if (n) { n.isPending = false; n._selected = true; await renderImportList(); } }
        if (t.classList.contains('btn-reject-import')) { const vid = t.dataset.vid; const id = parseInt(t.dataset.id); tempNoteSession[vid] = tempNoteSession[vid].filter(x => x.id !== id); await renderImportList(); }
        if (t.classList.contains('import-check')) { const vid = t.dataset.vid; const id = parseInt(t.dataset.id); const n = tempNoteSession[vid].find(x => x.id === id); if (n) { n._selected = t.checked; await renderImportList(); } }
        const edit = e.target.closest('.import-btn-icon.edit');
        if (edit) { const vid = edit.dataset.vid; const id = parseInt(edit.dataset.id); const n = tempNoteSession[vid].find(x => x.id === id); if (n) { n._editing = true; await renderImportList(); } }
        const del = e.target.closest('.import-btn-icon.delete');
        if (del) { if(confirm('¿Eliminar esta nota del gestor?')) { const vid = del.dataset.vid; const id = parseInt(del.dataset.id); tempNoteSession[vid] = tempNoteSession[vid].filter(x => x.id !== id); await renderImportList(); } }

      
      
      
      
      
// DENTRO DE initializeImportModalListeners() ... document.getElementById('import-list-container').addEventListener('click', ...
if (t.classList.contains('save-import-edit')) {
    const vid = t.dataset.vid; 
    const id = parseInt(t.dataset.id);
    
    const newT = document.getElementById(`edit-time-${id}`).value;
    const newTi = document.getElementById(`edit-title-${id}`).value;
    
    // CAMBIO AQUI: Obtener contenido desde Quill
    const editorDiv = document.getElementById(`edit-editor-${id}`);
    let newTx = '';
    if (editorDiv && editorDiv._quill) {
        newTx = editorDiv._quill.root.innerHTML; // Obtener HTML
    } else {
        // Fallback por si acaso
        newTx = tempNoteSession[vid].find(x => x.id === id).text;
    }

    const vidSel = document.getElementById(`edit-video-${id}`);
    const newVid = vidSel ? vidSel.value : vid;
    const ps = parseTime(newT);
    
    // Validación más flexible (permite imágenes/iframe sin texto)
    const hasContent = editorDiv._quill.getText().trim().length > 0 || newTx.includes('<img') || newTx.includes('<iframe');

    if (ps !== null && hasContent) {
        const idx = tempNoteSession[vid].findIndex(x => x.id === id);
        if (idx > -1) {
            const note = tempNoteSession[vid][idx];
            note.timestamp = newT; 
            note.timestampSeconds = ps; 
            note.title = newTi; 
            note.text = newTx; 
            note._editing = false;
            
            if (newVid !== vid) { 
                tempNoteSession[vid].splice(idx, 1); 
                if (!tempNoteSession[newVid]) tempNoteSession[newVid] = []; 
                tempNoteSession[newVid].push(note); 
            }
            await initImportSearch(); 
            await renderImportList();
        }
    } else {
        alert('Tiempo inválido o contenido vacío.');
    }
}      
      
      
      
      
      
      
      
        if (t.classList.contains('cancel-import-edit')) { const vid = t.dataset.vid; const id = parseInt(t.dataset.id); const n = tempNoteSession[vid].find(x => x.id === id); if (n) { n._editing = false; await renderImportList(); } }
    });
    document.getElementById('select-all-import').addEventListener('change', async (e) => { const checked = e.target.checked; Object.keys(tempNoteSession).forEach(vid => { tempNoteSession[vid].forEach(n => { if (!n.isPending) { n._selected = checked; } }); }); await renderImportList(); });
}      

function getLayoutMode() { const width = window.innerWidth; if (width > 1400) return 'PC'; if (width > 1100) return 'TABLET'; return 'MOBILE'; }
let currentMode = getLayoutMode();
function resetSidebarToDefault() { const sidebar = document.querySelector('.app-sidebar'); const body = document.body; body.classList.remove('overlay-active'); body.classList.remove('sidebar-hover-active'); sidebar.classList.remove('mobile-open'); sidebar.classList.add('collapsed'); body.classList.add('sidebar-collapsed'); }
window.addEventListener('resize', () => { const newMode = getLayoutMode(); if (newMode !== currentMode) { resetSidebarToDefault(); currentMode = newMode; } });
document.addEventListener('DOMContentLoaded', () => { if (currentMode === 'MOBILE') { const sidebar = document.querySelector('.app-sidebar'); sidebar.classList.remove('mobile-open'); } });

  
  
  
  
  
  
  
  
  
  
// --- FUNCIÓN MAESTRA DE MEJORA DE UI ---
function enhanceQuillToolbar(quillInstance) {
    const toolbar = quillInstance.getModule('toolbar').container;
    const parent = toolbar.parentNode;

    // 1. Wrapper y Flechas (Tu código original de scroll horizontal)
    if (!parent.classList.contains('quill-toolbar-wrapper')) {
        const wrapper = document.createElement('div');
        wrapper.className = 'quill-toolbar-wrapper';
        const leftBtn = document.createElement('button');
        leftBtn.className = 'toolbar-arrow toolbar-arrow-left';
        leftBtn.innerHTML = '<i class="fa-solid fa-chevron-left"></i>';
        const rightBtn = document.createElement('button');
        rightBtn.className = 'toolbar-arrow toolbar-arrow-right';
        rightBtn.innerHTML = '<i class="fa-solid fa-chevron-right"></i>';
        
        parent.insertBefore(wrapper, toolbar);
        wrapper.appendChild(leftBtn);
        wrapper.appendChild(toolbar);
        wrapper.appendChild(rightBtn);

        initializeDraggable(toolbar);

        const checkArrows = () => {
            const tol = 2;
            leftBtn.style.display = toolbar.scrollLeft > tol ? 'grid' : 'none';
            rightBtn.style.display = toolbar.scrollLeft < (toolbar.scrollWidth - toolbar.clientWidth - tol) ? 'grid' : 'none';
        };
        leftBtn.onclick = (e) => { e.preventDefault(); toolbar.scrollBy({ left: -200, behavior: 'smooth' }); };
        rightBtn.onclick = (e) => { e.preventDefault(); toolbar.scrollBy({ left: 200, behavior: 'smooth' }); };
        toolbar.addEventListener('scroll', checkArrows);
        window.addEventListener('resize', checkArrows);
        setTimeout(checkArrows, 100);
    }

    // 2. MEJORAS DE LOS PICKERS (Fuentes, Colores, Tamaño)
    upgradePickers(toolbar, quillInstance);
}

// --- PASO 3: FUNCIÓN UPGRADE PICKERS COMPLETAMENTE NUEVA ---
function upgradePickers(toolbar, quill) {

    // --- A. POSICIONAMIENTO PEGAJOSO GLOBAL (Sticky) ---
    const updatePickerPosition = () => {
        // Busca CUALQUIER picker expandido (Font, Size, Color, etc.)
        const expanded = document.querySelectorAll('.ql-picker.ql-expanded');
        expanded.forEach(picker => {
            const label = picker.querySelector('.ql-picker-label');
            const options = picker.querySelector('.ql-picker-options');
            if (label && options) {
                const rect = label.getBoundingClientRect();
                // Forzar posición fija pegada al label
                options.style.position = 'fixed';
                options.style.left = `${rect.left}px`;
                options.style.top = `${rect.bottom + 2}px`;
                // Ajuste si se sale de la pantalla (derecha)
                if (rect.left + 160 > window.innerWidth) {
                    options.style.left = `${window.innerWidth - 170}px`;
                }
            }
        });
    };
    // Escuchar scroll global y resize para recalcular
    window.addEventListener('scroll', updatePickerPosition, true);
    window.addEventListener('resize', updatePickerPosition);
    // Asignar el evento a TODOS los labels para que calculen al abrir
    toolbar.querySelectorAll('.ql-picker-label').forEach(label => {
        label.addEventListener('mousedown', () => setTimeout(updatePickerPosition, 0));
        label.addEventListener('click', () => setTimeout(updatePickerPosition, 0));
    });

    // --- B. MEJORA DE FUENTES (Search & Favorites Fix) ---
// --- B. MEJORA DE FUENTES (CORREGIDA) ---
// --- B. MEJORA DE FUENTES (CORREGIDA Y SINCRONIZADA) ---
    const fontPicker = toolbar.querySelector('.ql-font');
    if (fontPicker) {
        const optionsContainer = fontPicker.querySelector('.ql-picker-options');
        
        // 1. Clonamos los items originales para no perder referencias
        const originalItems = Array.from(optionsContainer.querySelectorAll('.ql-picker-item'));

        // 2. Crear elementos de UI (Buscador y Favoritos)
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Buscar fuente...';
        searchInput.className = 'picker-search-input';
        
        const favContainer = document.createElement('div');
        favContainer.className = 'picker-favorites-section';
        favContainer.style.display = 'none';
        favContainer.innerHTML = '<div class="picker-fav-label"><i class="fa-solid fa-star" style="color:gold;"></i> Favoritos</div>';

        // 3. Insertar al principio
        optionsContainer.prepend(favContainer);
        optionsContainer.prepend(searchInput);

        // 4. Lógica para aplicar fuente manualmente
        const applyFontManual = (fontName) => {
            quill.format('font', fontName); // Aplica al texto
            
            // Actualiza visualmente la etiqueta
            const label = fontPicker.querySelector('.ql-picker-label');
            if (label) {
                label.setAttribute('data-value', fontName);
                // Forzar cierre del menú visualmente
                label.classList.remove('ql-active');
                fontPicker.classList.remove('ql-expanded');
            }
        };

        // 5. Procesar items originales
        originalItems.forEach(item => {
            const fontName = item.dataset.value || ''; 
            item.style.fontFamily = fontName || 'sans-serif'; 
            
            // Override del click
            item.addEventListener('mousedown', (e) => {
                if (e.target.closest('.picker-item-actions')) return; 
                e.preventDefault(); 
                e.stopPropagation();
                applyFontManual(fontName);
            });

            // Estrella de favorito
            const star = document.createElement('span');
            star.className = 'picker-item-actions';
            star.innerHTML = '<i class="fa-regular fa-star"></i>';
            star.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                if (FavManager.has('font', fontName)) {
                    FavManager.remove('font', fontName);
                } else {
                    FavManager.add('font', fontName);
                }
                refreshFontList();
            };
            item.appendChild(star);
        });

        // 6. Lógica de renderizado de lista (Buscador/Favs)
        const refreshFontList = () => {
            const term = searchInput.value.toLowerCase();
            const favs = FavManager.get('font');
            
            favContainer.querySelectorAll('.ql-picker-item').forEach(el => el.remove());
            let hasFavs = false;

            // Renderizar Favoritos Arriba
            favs.forEach(favFont => {
                hasFavs = true;
                const div = document.createElement('div');
                div.className = 'ql-picker-item picker-fav-item';
                div.style.fontFamily = favFont || 'sans-serif';
                div.innerHTML = `<span>${favFont || 'Sans Serif'}</span> <i class="fa-solid fa-star" style="color:gold; cursor:pointer;"></i>`;
                
                div.onclick = (e) => {
                    if (e.target.tagName === 'I') { 
                        e.stopPropagation();
                        FavManager.remove('font', favFont);
                        refreshFontList();
                        return;
                    }
                    applyFontManual(favFont);
                };
                favContainer.appendChild(div);
            });
            favContainer.style.display = hasFavs ? 'block' : 'none';

            // Filtrar lista principal
            originalItems.forEach(item => {
                const val = item.dataset.value || '';
                const star = item.querySelector('.picker-item-actions');
                
                if(favs.includes(val)) {
                    item.classList.add('is-favorite');
                    star.innerHTML = '<i class="fa-solid fa-star" style="color:gold;"></i>';
                } else {
                    item.classList.remove('is-favorite');
                    star.innerHTML = '<i class="fa-regular fa-star"></i>';
                }
                
                const displayName = val || 'sans serif';
                if (displayName.toLowerCase().includes(term)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        };

        searchInput.addEventListener('input', refreshFontList);
        searchInput.addEventListener('click', (e) => e.stopPropagation());
        refreshFontList(); 

        // ==========================================================
        // === 7. EL FIX QUE NECESITAS (SINCRONIZACIÓN CONSTANTE) ===
        // ==========================================================
        // Este evento se dispara cada vez que mueves el cursor o cambias un formato (tamaño, negrita).
        // Forzamos a que la etiqueta SIEMPRE muestre la fuente real actual.
// ==========================================================
        // === 7. FIX: SINCRONIZACIÓN DE ETIQUETAS (FUENTE E INTERLINEADO) ===
        // ==========================================================
// ==========================================================
    // === 7. SINCRONIZACIÓN ROBUSTA DE ETIQUETAS (FUENTE E INTERLINEADO) ===
    // ==========================================================
    quill.on('editor-change', (eventName, ...args) => {
        if (eventName === 'selection-change') {
            const range = args[0];
            if (range) {
                const formats = quill.getFormat(range);
                
                // --- A) Sincronizar FUENTE ---
                const currentFont = formats.font || ''; 
                const fontLabel = toolbar.querySelector('.ql-font .ql-picker-label');
                if (fontLabel) {
                    fontLabel.setAttribute('data-value', currentFont);
                }

// --- B) Sincronizar INTERLINEADO (FIX MEJORADO) ---
                let currentLineHeight = formats.lineheight;

                // Quill a veces devuelve un array si seleccionas texto con varios interlineados.
                if (Array.isArray(currentLineHeight)) {
                    currentLineHeight = ''; 
                }
                
                // Si es undefined o null, es "Normal"
                if (!currentLineHeight) {
                    currentLineHeight = ''; 
                } else {
                    // FIX: Forzar que los enteros tengan el ".0" para que coincida con el CSS y Whitelist
                    currentLineHeight = String(currentLineHeight);
                    if (currentLineHeight === '1') currentLineHeight = '1.0';
                    if (currentLineHeight === '2') currentLineHeight = '2.0';
                    if (currentLineHeight === '3') currentLineHeight = '3.0';
                }

                const lineLabel = toolbar.querySelector('.ql-lineheight .ql-picker-label');
                if (lineLabel) {
                    // 1. Actualizamos el data-value para el CSS content: attr(data-value)
                    lineLabel.setAttribute('data-value', currentLineHeight);
                    
                    // 2. FUERZA BRUTA VISUAL (Backup): 
                    // Si el CSS no carga o falla, esto cambia el texto interno del SVG o span del label
                    // Esto asegura que veas el número sí o sí.
                    if (currentLineHeight) {
                         // Buscamos si hay un elemento de texto dentro o usamos el data-value
                         // El CSS debería encargarse, pero esto refresca el DOM.
                         lineLabel.style.setProperty('--content-value', `"${currentLineHeight}"`);
                    }
                }
            }
        }
    });
    }
  
  
  
  
  
  // --- C. MEJORA DE COLORES Y FONDO (Lógica Unificada con Tachito de Borrado) ---
    const colorPickers = toolbar.querySelectorAll('.ql-color, .ql-background');
    
    colorPickers.forEach(picker => {
        // Determinar si es para color de texto o fondo
        const type = picker.classList.contains('ql-background') ? 'background' : 'color';
        const labelText = type === 'background' ? 'Fondo' : 'Texto';
        const optionsContainer = picker.querySelector('.ql-picker-options');

        // 1. Limpiar contenedor original
        optionsContainer.innerHTML = ''; 

        // 2. Estado local para el modo eliminación
        let isDeleteMode = false;
        let selectedForDeletion = new Set(); // Almacena colores marcados para borrar

        // 3. Crear UI Personalizada
        const customUI = document.createElement('div');
        customUI.style.cssText = 'display:flex; flex-direction:column; gap:8px; padding: 5px; width: 100%;;';
        
        customUI.innerHTML = `
            <div style="font-size:11px; color:#888; font-weight:600; text-transform:uppercase; margin-bottom:-4px;">${labelText}</div>
            <div style="display: grid; align-items:center; grid-template-columns: repeat(2, 0.5fr); gap:5px;">
                <input type="color" class="custom-wheel" style="width:30px; height:30px; border:none; padding:0; cursor:pointer; background:none;">
                <input type="text" class="custom-hex" placeholder="#000000" style="width:70px; font-size:12px; padding:4px; border:1px solid #ccc; border-radius:4px; text-transform:uppercase;">
                
                <button class="custom-save-fav" title="Guardar en favoritos" style="background:none; border:none; cursor:pointer; color:#ccc; transition:0.2s;">
                    <i class="fa-regular fa-star"></i>
                </button>
                
                <button class="custom-trash-mode" title="Eliminar favoritos" style="background:none; border:none; cursor:pointer; color:#ccc; transition:0.2s;">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            
            <button class="custom-apply-btn" style="width:100%; background:var(--color-primary); color:white; border:none; border-radius:4px; cursor:pointer; font-size:12px; font-weight:500;">
                Aplicar Color
            </button>
            
            <div class="custom-favs-area" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:5px; padding-top:8px; border-top:1px solid #eee; min-height:25px;">
            </div>
            <div class="delete-hint" style="font-size:10px; color:#e53e3e; display:none; text-align:center;">Selecciona para borrar</div>
        `;
        
        optionsContainer.appendChild(customUI);

        // Referencias a elementos
        const wheel = customUI.querySelector('.custom-wheel');
        const hexInput = customUI.querySelector('.custom-hex');
        const saveBtn = customUI.querySelector('.custom-save-fav');
        const trashBtn = customUI.querySelector('.custom-trash-mode');
        const applyBtn = customUI.querySelector('.custom-apply-btn');
        const favArea = customUI.querySelector('.custom-favs-area');
        const deleteHint = customUI.querySelector('.delete-hint');

        // Sincronizar Rueda <-> Input Hex
        wheel.addEventListener('input', (e) => hexInput.value = e.target.value);
        hexInput.addEventListener('input', (e) => {
            if(e.target.value.startsWith('#') && e.target.value.length === 7) {
                wheel.value = e.target.value;
            }
        });

        // Función Aplicar Color
        const applyAction = () => {
            const val = hexInput.value || '#000000';
            quill.format(type, val); // Aplica 'color' o 'background' según corresponda
            // Cerrar menú
            const label = picker.querySelector('.ql-picker-label');
            if(label) label.click();
        };
        applyBtn.addEventListener('click', applyAction);

        // Función Renderizar Favoritos
        const renderFavs = () => {
            const favs = FavManager.get(type); // Obtiene favoritos de 'color' o 'background'
            favArea.innerHTML = '';
            
            if (favs.length === 0) {
                favArea.innerHTML = '<span style="grid-column:1/-1; font-size:10px; color:#ccc; text-align:center;">Sin favoritos</span>';
                return;
            }

            favs.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.cssText = 'width:24px; height:24px; border-radius:4px; cursor:pointer; border:1px solid #ddd; position:relative;';
                swatch.style.backgroundColor = color;
                swatch.title = color;

                // Si estamos en modo eliminar y está seleccionado
                if (isDeleteMode && selectedForDeletion.has(color)) {
                    swatch.style.border = '2px solid #e53e3e';
                    swatch.style.opacity = '0.7';
                    // Icono X pequeño encima
                    swatch.innerHTML = '<div style="position:absolute; inset:0; display:grid; place-items:center; color:#e53e3e;"><i class="fa-solid fa-xmark"></i></div>';
                }

                swatch.onclick = (e) => {
                    e.stopPropagation(); // Evitar cierre del menú
                    
                    if (isDeleteMode) {
                        // Lógica de selección para borrar
                        if (selectedForDeletion.has(color)) {
                            selectedForDeletion.delete(color);
                        } else {
                            selectedForDeletion.add(color);
                        }
                        renderFavs(); // Re-renderizar para mostrar borde rojo
                    } else {
                        // Lógica normal: Cargar en inputs
                        wheel.value = color;
                        hexInput.value = color;
                        // Opcional: Aplicar directamente al hacer click
                        // quill.format(type, color);
                    }
                };

                favArea.appendChild(swatch);
            });
        };

        // Guardar Favorito (Estrella)
        saveBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const val = hexInput.value;
            if (val && val.startsWith('#')) {
                FavManager.add(type, val); // Guarda en 'quill_fav_color' o 'quill_fav_background'
                
                // Feedback visual
                saveBtn.style.color = 'gold';
                saveBtn.innerHTML = '<i class="fa-solid fa-star"></i>';
                setTimeout(() => {
                    saveBtn.style.color = '#ccc';
                    saveBtn.innerHTML = '<i class="fa-regular fa-star"></i>';
                }, 800);

                // Si estamos en modo borrar, salimos para mostrar el nuevo item
                if(isDeleteMode) {
                    isDeleteMode = false;
                    trashBtn.style.color = '#ccc';
                    deleteHint.style.display = 'none';
                    selectedForDeletion.clear();
                }
                renderFavs();
            } else {
                alert('Selecciona un color válido primero');
            }
        });

        // Botón Tachito (Modo Borrar)
        trashBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            
            if (!isDeleteMode) {
                // ACTIVAR MODO BORRAR
                isDeleteMode = true;
                selectedForDeletion.clear();
                trashBtn.style.color = '#e53e3e'; // Rojo
                deleteHint.style.display = 'block';
                renderFavs();
            } else {
                // DESACTIVAR / EJECUTAR BORRADO
                if (selectedForDeletion.size > 0) {
                    // Si hay seleccionados, borrarlos
                    selectedForDeletion.forEach(colorToDelete => {
                        FavManager.remove(type, colorToDelete);
                    });
                    selectedForDeletion.clear();
                }
                
                // Volver a estado normal
                isDeleteMode = false;
                trashBtn.style.color = '#ccc';
                deleteHint.style.display = 'none';
                renderFavs();
            }
        });

        // Inicializar lista
        renderFavs();
    });
  

  
  
  
  
  
  
  
  
  
  
  
  
    // --- D. MEJORA DE TAMAÑO (Input Manual + Favoritos) ---
    const sizePicker = toolbar.querySelector('.ql-size');
    if (sizePicker) {
        const optionsContainer = sizePicker.querySelector('.ql-picker-options');
        
        // 1. Limpiar opciones predeterminadas (o ocultarlas)
        optionsContainer.innerHTML = '';

        // 2. Crear estructura (Input arriba, Favoritos abajo)
        const customUI = document.createElement('div');
        customUI.innerHTML = `
            <div style="display:flex; align-items:center; gap:5px; padding-bottom:8px; border-bottom:1px solid #eee;">
                <input type="number" class="size-input picker-input-custom" placeholder="16" style="margin:0; width:60px;">
                <span style="font-size:12px; color:#666;">px</span>
                <button class="size-save-btn" style="border:none; background:none; cursor:pointer; color:#ccc;">
                    <i class="fa-regular fa-star"></i>
                </button>
            </div>
            <button class="size-apply-btn" style="width:100%; margin-top:5px; background:var(--color-primary); color:white; border:none; padding:5px; border-radius:4px; cursor:pointer;">
                Aplicar
            </button>
            <div class="size-favs-list" style="margin-top:5px;"></div>
        `;
        optionsContainer.appendChild(customUI);

        const input = customUI.querySelector('.size-input');
        const saveBtn = customUI.querySelector('.size-save-btn');
        const applyBtn = customUI.querySelector('.size-apply-btn');
        const list = customUI.querySelector('.size-favs-list');

        const applySize = (val) => {
            if (!val) return;
            // Asegurar que termine en 'px'
            const finalVal = val.toString().includes('px') ? val : `${val}px`;
            
            // IMPORTANTE: Quill necesita que el valor esté en el whitelist
            // Como usamos Size.whitelist en la config, debemos asegurarnos
            // de que el valor sea válido o Quill lo ignorará.
            // PERO como registramos 'true' en el registro, debería aceptar todo.
            // Si falla, agregamos temporalmente al whitelist de la instancia.
            quill.format('size', finalVal);
            sizePicker.querySelector('.ql-picker-label').click(); // Cerrar
            
            // Actualizar label visualmente (opcional)
            sizePicker.querySelector('.ql-picker-label').setAttribute('data-value', finalVal);
        };

        applyBtn.addEventListener('click', () => applySize(input.value));
        input.addEventListener('keydown', (e) => { if(e.key==='Enter') applySize(input.value); });

        const renderSizeFavs = () => {
            const favs = FavManager.get('size');
            list.innerHTML = '';
            if (favs.length === 0) list.innerHTML = '<small style="color:#999; display:block; text-align:center;">Sin favoritos</small>';
            
            favs.forEach(size => {
                const item = document.createElement('div');
                item.className = 'picker-fav-item';
                item.innerHTML = `<span>${size}</span> <i class="fa-solid fa-trash" style="font-size:10px; color:#ccc;"></i>`;
                
                // Clic en el número -> Aplicar
                item.onclick = (e) => {
                    if (e.target.tagName === 'I') return; // Ignorar clic en basura
                    input.value = size.replace('px','');
                    applySize(size);
                };

                // Clic en basura -> Borrar
                item.querySelector('i').onclick = (e) => {
                    e.stopPropagation();
                    FavManager.remove('size', size);
                    renderSizeFavs();
                };
                list.appendChild(item);
            });
        };

        saveBtn.addEventListener('click', () => {
            const val = input.value;
            if (val) {
                const sizeVal = val.includes('px') ? val : `${val}px`;
                FavManager.add('size', sizeVal);
                renderSizeFavs();
                saveBtn.innerHTML = '<i class="fa-solid fa-star" style="color:gold"></i>';
                setTimeout(() => saveBtn.innerHTML = '<i class="fa-regular fa-star"></i>', 1000);
            }
        });

        renderSizeFavs();
    }
}

  

  
  
  
  
  
// =========================================================
// === 9. SISTEMA DE BÚSQUEDA INTELIGENTE EN NOTAS ===
// =========================================================

const NotesSearchSystem = {
    originalContentMap: new Map(), // Guardamos el texto original para poder limpiar el resaltado

    init() {
        const inputContainer = document.querySelector('.notes-search-input-container');
        if(!inputContainer) return;

        const input = document.getElementById('notes-smart-search');
        const searchIcon = inputContainer.querySelector('i');

        // Limpiar listeners antiguos clonando
        const newInput = input.cloneNode(true);
        input.parentNode.replaceChild(newInput, input);
        
        const newIcon = searchIcon.cloneNode(true);
        searchIcon.parentNode.replaceChild(newIcon, searchIcon);

        // EVENTO 1: Presionar ENTER en el input
        newInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.performSearch(newInput.value);
            }
        });

        // EVENTO 2: Clic en el icono de lupa
        newIcon.addEventListener('click', () => {
            this.performSearch(newInput.value);
        });
        
        // EVENTO 3: Limpiar búsqueda si se borra todo el texto
        newInput.addEventListener('input', (e) => {
             if(e.target.value.trim() === '') {
                 this.clearSearch();
             }
        });

        // Inicializar mapa de contenido original (solo la primera vez)
        this.indexOriginalContent();
    },

    indexOriginalContent() {
        // Guardamos el HTML original de cada nota para restaurarlo al limpiar búsqueda
        document.querySelectorAll('.note-item').forEach(el => {
            const id = el.dataset.id;
            const titleEl = el.querySelector('.note-title');
            const textEl = el.querySelector('.note-text-display');
            
            if (id && textEl && !this.originalContentMap.has(id)) {
                this.originalContentMap.set(id, {
                    titleHTML: titleEl ? titleEl.innerHTML : '',
                    textHTML: textEl.innerHTML
                });
            }
        });
    },
    
    // Llamar a esto cuando se agregan/editan notas para actualizar el caché
    reIndex() {
        this.originalContentMap.clear();
        this.indexOriginalContent();
    },

// DENTRO DE NotesSearchSystem:
performSearch(query) {
    query = query.trim(); // No hacemos toLowerCase aquí porque getSmartRegex manejará mayúsculas/minúsculas
    const input = document.getElementById('notes-smart-search');
    
    if (!query) {
        this.clearSearch();
        return;
    }

    input.classList.add('searching');
    
    if(this.originalContentMap.size === 0) this.indexOriginalContent();

    const allAccordions = document.querySelectorAll('.note-accordion-item');
    const allNotes = document.querySelectorAll('.note-item');
    const activeAccordions = new Set();
    let foundCount = 0;

    // --- CAMBIO CLAVE: Usamos getSmartRegex ---
    const regex = getSmartRegex(query);

    allNotes.forEach(noteEl => {
        const id = noteEl.dataset.id;
        const originalData = this.originalContentMap.get(id);
        
        if (!originalData) return;

        // Búsqueda sobre el texto original (HTML)
        // Probamos si el regex coincide con el título o el contenido
        const titleMatch = regex.test(originalData.titleHTML);
        // Reseteamos lastIndex porque es 'global' y si test() devuelve true avanza el puntero
        regex.lastIndex = 0; 
        const textMatch = regex.test(originalData.textHTML);
        regex.lastIndex = 0;

        if (titleMatch || textMatch) {
            foundCount++;
            noteEl.style.display = 'flex';
            
            const parent = noteEl.closest('.note-accordion-item');
            if (parent) activeAccordions.add(parent);

            // --- APLICAR RESALTADO INTELIGENTE ---
            const titleEl = noteEl.querySelector('.note-title');
            const textEl = noteEl.querySelector('.note-text-display');

            if (titleEl && titleMatch) {
                titleEl.innerHTML = highlightTextSmart(originalData.titleHTML, query);
            }
            
            if (textEl && textMatch) {
                textEl.innerHTML = highlightTextSmart(originalData.textHTML, query);
            }

        } else {
            noteEl.style.display = 'none';
        }
    });

    allAccordions.forEach(acc => {
        if (activeAccordions.has(acc)) {
            acc.style.display = 'block';
            acc.classList.add('open');
        } else {
            acc.style.display = 'none';
        }
    });
    
    setTimeout(() => input.classList.remove('searching'), 300);
},

    clearSearch() {
        const input = document.getElementById('notes-smart-search');
        if(input) input.value = '';
        input.classList.remove('searching');

        // Restaurar HTML original (elimina resaltados)
        document.querySelectorAll('.note-item').forEach(noteEl => {
            noteEl.style.display = 'flex'; // Mostrar todas
            const id = noteEl.dataset.id;
            const originalData = this.originalContentMap.get(id);
            
            if (originalData) {
                const titleEl = noteEl.querySelector('.note-title');
                const textEl = noteEl.querySelector('.note-text-display');
                if(titleEl) titleEl.innerHTML = originalData.titleHTML;
                if(textEl) textEl.innerHTML = originalData.textHTML;
            }
        });

        // Restaurar acordeones
        document.querySelectorAll('.note-accordion-item').forEach(acc => {
            acc.style.display = 'block';
            // Opcional: Cerrar acordeones al limpiar o dejarlos como estaban
            // acc.classList.remove('open'); 
        });
    },
    
    // Método auxiliar para llamar al agregar/editar notas y actualizar índices
    indexNotes() {
        this.reIndex();
    }
};

// =========================================================
// === 10. SISTEMA DE NOTAS FLOTANTES (POPUP) ===
// =========================================================
// =========================================================
// === 10. SISTEMA DE NOTAS FLOTANTES (GLOBAL Y ROBUSTO) ===
// =========================================================

// 1. CREAMOS EL ALMACÉN GLOBAL (INDDESTRUCTIBLE)
window.globalFloatingEditors = {}; 

const FloatingNoteSystem = {
    zIndexCounter: 10000,

    // --- ABRIR EL POPUP ---
    async open(noteId, videoId) {
        // Aseguramos que noteId sea número para buscar en DB
        const numId = Number(noteId);
        
        const notes = await db.get('notes', videoId, []);
        const note = notes.find(n => n.id === numId);
        
        if (!note) {
            console.error("Nota no encontrada:", noteId);
            return;
        }

        const popupId = `popup-${numId}`;
        const existing = document.getElementById(popupId);
        
        if (existing) {
            this.bringToFront(existing);
            return;
        }

        const popup = document.createElement('div');
        popup.id = popupId;
        popup.className = 'floating-note-popup';
        // Posición inicial segura
        popup.style.top = '15%'; 
        popup.style.left = '60%';
        popup.style.width = '400px';
        popup.style.height = '450px';
        
        this.bringToFront(popup);

        // Renderizamos HTML
        popup.innerHTML = `
            <div class="floating-note-header">
                <div class="floating-drag-handle">
                    <i class="fa-solid fa-grip-vertical"></i> 
                    <span id="popup-title-display-${numId}" style="font-weight:600; font-size:0.9rem;">${note.title || 'Nota sin título'}</span>
                </div>
                <button class="close-floating-btn" onclick="FloatingNoteSystem.close('${popupId}', ${numId})">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            
            <div class="floating-note-body" id="popup-body-${numId}" style="position:relative; height:100%; display:flex; flex-direction:column;">
                
                <div class="popup-view-mode" style="display:flex; flex-direction:column; height:100%;">
                    <div class="popup-actions-wrapper">
                         <button class="icon-action-btn" onclick="FloatingNoteSystem.enableEdit(${numId}, '${videoId}')" title="Editar aquí">
                            <i class="fa-solid fa-pencil"></i>
                        </button>
                        <button class="icon-action-btn" style="color:var(--color-error);" onclick="FloatingNoteSystem.delete(${numId}, '${videoId}', '${popupId}')" title="Eliminar">
                            <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                    <div class="popup-content-wrapper" style="overflow-y:auto; flex-grow:1;">
                        <div class="note-header" style="margin-bottom:10px;">
                            <span class="timestamp main-seek" data-time="${note.timestampSeconds}" data-vid="${videoId}" style="color:var(--color-primary); font-weight:600; cursor:pointer;">
                                <i class="fa-solid fa-play"></i> ${note.timestamp}
                            </span>
                        </div>
                        <div class="note-text-display ql-editor" id="popup-text-content-${numId}" style="padding:0;">
                            ${note.text}
                        </div>
                    </div>
                </div>
                
                <div class="popup-edit-mode" style="display:none; height:100%; flex-direction:column; gap:10px;">
                     <div style="display:grid; grid-template-columns: 80px 1fr; gap:5px; flex-shrink:0;">
                        <input type="text" id="popup-edit-time-${numId}" class="note-time-input" value="${note.timestamp}">
                        <input type="text" id="popup-edit-title-${numId}" class="note-title-input" value="${note.title || ''}" placeholder="Título">
                     </div>
                     
                     <div class="popup-quill-wrapper" id="popup-quill-wrapper-${numId}" style="flex-grow:1; display:flex; flex-direction:column; overflow:hidden; border:1px solid #ccc; border-radius:8px; background:#fff;">
                     </div>
                     
                     <div style="display:flex; justify-content:flex-end; gap:5px; flex-shrink:0; padding-top:5px;">
                        <button class="button button-secondary" onclick="FloatingNoteSystem.cancelEdit(${numId})">Cancelar</button>
                        <button class="button button-primary" onclick="FloatingNoteSystem.saveEdit(${numId}, '${videoId}')">Guardar</button>
                     </div>
                </div>
            </div>
            <div class="floating-resize-handle"></div>
        `;

        document.body.appendChild(popup);
        this.makeDraggable(popup);
        this.makeResizable(popup); 
        popup.addEventListener('mousedown', () => this.bringToFront(popup));
    },

    // --- ACTIVAR EDICIÓN (GLOBALIZADO) ---
// --- ACTIVAR EDICIÓN (GLOBALIZADO) ---
    async enableEdit(noteId, videoId) {
        // Aseguramos ID consistente
        const strId = String(noteId); 
        const numId = Number(noteId);

        const popupBody = document.getElementById(`popup-body-${numId}`);
        const notes = await db.get('notes', videoId, []);
        const note = notes.find(n => n.id === numId);
        
        if(!note || !popupBody) return;

        // Limpieza preventiva: Si ya existe un editor en memoria global para esta nota, bórralo
        if (window.globalFloatingEditors[strId]) {
            delete window.globalFloatingEditors[strId];
        }

        // Cambio visual
        popupBody.querySelector('.popup-view-mode').style.display = 'none';
        popupBody.querySelector('.popup-edit-mode').style.display = 'flex';

        const wrapper = document.getElementById(`popup-quill-wrapper-${numId}`);
        wrapper.innerHTML = ''; // Limpiamos contenedor HTML
        
        // Creamos el div donde Quill se montará
        const editorDiv = document.createElement('div');
        editorDiv.style.flexGrow = '1';
        editorDiv.style.border = 'none';
        wrapper.appendChild(editorDiv);

        // Inicializamos Quill (PRIMERO VACÍO)
        setTimeout(() => {
            const q = new Quill(editorDiv, {
                theme: 'snow',
modules: { 
        toolbar: fullToolbarOptions,
        blotFormatter: blotFormatterConfig // <--- ASÍ
    }
            });

            // AQUI ESTA LA MAGIA: Inyectamos el HTML DESPUÉS de que Quill existe
            q.root.innerHTML = note.text; 

            fixBlotFormatterAlignment(q); // <--- AÑADE ESTA LÍNEA AQUÍ          
          
          
            // --- CORRECCIÓN BUG SCROLL IMAGEN (PARA POPUP) ---
            q.root.addEventListener('scroll', function() {
                if (q.getModule('blotFormatter')) {
                    q.getModule('blotFormatter').hide();
                }
            });

            // ============================================================
            // === FIX AGREGADO: REAJUSTE AL REDIMENSIONAR EL POPUP ===
            // ============================================================
            // Si cambias el tamaño del popup, ocultamos los manejadores para que no queden flotando.
            // Al hacer clic de nuevo en la imagen, aparecerán en el lugar correcto.
            const resizeObserver = new ResizeObserver(() => {
                const resizer = q.getModule('blotFormatter');
                if (resizer) {
                    resizer.hide(); 
                }
            });
            resizeObserver.observe(editorDiv);
            // ============================================================
            
            // 1. PRIMERO: Guardar en la memoria global
            window.globalFloatingEditors[strId] = q;
            
            // Backup por si acaso
            wrapper._quillRef = q; 
            
            console.log(`Editor para nota ${strId} guardado en memoria global exitosamente.`);

            // 2. SEGUNDO: Aplicar mejoras visuales (Toolbar y Sync de LineHeight)
            try {
                enhanceQuillToolbar(q); 
            } catch (error) {
                console.warn("Aviso toolbar popup", error);
            }
            
            // 3. TERCERO: Dar foco al editor
            q.focus();
        }, 50);
    },

    // --- CANCELAR EDICIÓN ---
    cancelEdit(noteId) {
        const strId = String(noteId);
        const numId = Number(noteId);
        
        const popupBody = document.getElementById(`popup-body-${numId}`);
        if(!popupBody) return;
        
        // Limpiamos memoria GLOBAL
        if (window.globalFloatingEditors[strId]) {
            delete window.globalFloatingEditors[strId];
        }

        const wrapper = document.getElementById(`popup-quill-wrapper-${numId}`);
        if(wrapper) {
            wrapper.innerHTML = '';
            wrapper._quillRef = null;
        }

        popupBody.querySelector('.popup-edit-mode').style.display = 'none';
        popupBody.querySelector('.popup-view-mode').style.display = 'flex';
    },

    // --- GUARDAR CAMBIOS (GLOBALIZADO) ---
    async saveEdit(noteId, videoId) {
        const strId = String(noteId);
        const numId = Number(noteId);
        
        // 1. OBTENCIÓN DESDE GLOBAL
        let quillInstance = window.globalFloatingEditors[strId];

        // 2. RECUPERACIÓN DE EMERGENCIA (Si por alguna razón mágica se borró del global)
        if (!quillInstance) {
            console.warn(`Editor ${strId} no encontrado en global. Buscando en DOM...`);
            const wrapper = document.getElementById(`popup-quill-wrapper-${numId}`);
            if (wrapper && wrapper._quillRef) {
                quillInstance = wrapper._quillRef;
            }
        }

        // SI FALLA TODO:
        if (!quillInstance) {
            alert("Error crítico: El sistema perdió la conexión con el editor. Copia tu texto por seguridad y vuelve a abrir la nota.");
            return;
        }

        // EXTRAER DATOS
        const newText = quillInstance.root.innerHTML; 
        const cleanText = quillInstance.getText().trim();
        const newTitle = document.getElementById(`popup-edit-title-${numId}`).value;
        const newTimeStr = document.getElementById(`popup-edit-time-${numId}`).value;
        const newTimeSecs = parseTime(newTimeStr);

        const hasContent = cleanText.length > 0 || newText.includes('<img') || newText.includes('<iframe');

        if (newTimeSecs === null) { alert('Formato de tiempo inválido (use MM:SS)'); return; }
        if (!hasContent) { alert('No puedes guardar una nota vacía'); return; }

        try {
            // Obtener datos DB
            let notesArr = await db.get('notes', videoId, []);
            const idx = notesArr.findIndex(n => n.id === numId);
            
            if (idx !== -1) {
                // Actualizar objeto
                notesArr[idx] = { 
                    ...notesArr[idx], 
                    title: newTitle, 
                    text: newText, 
                    timestamp: newTimeStr, 
                    timestampSeconds: newTimeSecs,
                    updatedAt: Date.now()
                };
                
                // Guardar en DB
                await db.set('notes', videoId, notesArr);
                
                // Refrescar vistas
                this.refreshView(numId, notesArr[idx]);
                this.cancelEdit(numId); // Esto también limpia la memoria global

                // Actualizar acordeón principal
                if (currentVideoId === videoId) {
                    await renderNotesAccordions(currentVideoId);
                    if(typeof NotesSearchSystem !== 'undefined') NotesSearchSystem.reIndex();
                }
                
                console.log("Nota guardada exitosamente.");

            } else {
                alert("Error: La nota original ya no existe en la base de datos.");
            }
        } catch (e) {
            console.error("Error guardando:", e);
            alert("Error al guardar: " + e.message);
        }
    },

    // --- ELIMINAR NOTA ---
    delete(noteId, videoId, popupId) {
        if(confirm('¿Estás seguro de eliminar esta nota?')) {
             (async () => {
                try {
                    const numId = Number(noteId);
                    let notesArr = await db.get('notes', videoId, []);
                    const newNotes = notesArr.filter(n => n.id !== numId);
                    await db.set('notes', videoId, newNotes);
                    
                    if (currentVideoId === videoId) {
                        await renderNotesAccordions(currentVideoId);
                        if(typeof NotesSearchSystem !== 'undefined') NotesSearchSystem.reIndex();
                    }
                    this.close(popupId, numId);
                } catch (e) { console.error(e); }
            })();
        }
    },

    refreshView(noteId, noteObj) {
        const titleDisplay = document.getElementById(`popup-title-display-${noteId}`);
        if(titleDisplay) titleDisplay.textContent = noteObj.title || 'Nota sin título';
        
        const textDisplay = document.getElementById(`popup-text-content-${noteId}`);
        if(textDisplay) textDisplay.innerHTML = noteObj.text;
        
        const timeSpan = document.querySelector(`#popup-${noteId} .timestamp.main-seek`);
        if(timeSpan) {
            timeSpan.innerHTML = `<i class="fa-solid fa-play"></i> ${noteObj.timestamp}`;
            timeSpan.dataset.time = noteObj.timestampSeconds;
        }
    },

    close(popupId, noteId) {
        const strId = String(noteId);
        // Limpiamos memoria al cerrar
        if (window.globalFloatingEditors[strId]) {
            delete window.globalFloatingEditors[strId];
        }
        
        const el = document.getElementById(popupId);
        if(el) el.remove();
    },

    bringToFront(el) {
        this.zIndexCounter++;
        el.style.zIndex = this.zIndexCounter;
    },

   makeDraggable(el) {
        // YA NO buscamos solo el header, usaremos 'el' (todo el popup)
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;

        const startDrag = (e) => {
            const target = e.target;

            // 1. PROTECCIÓN: No arrastrar si tocamos el manejador de resize (esquina inferior derecha)
            if (target.classList.contains('floating-resize-handle')) return;

            // 2. PROTECCIÓN: No arrastrar si tocamos botones de cerrar o acciones
            if (target.closest('button') || target.closest('.icon-action-btn') || target.closest('.close-floating-btn')) return;

            // 3. PROTECCIÓN: No arrastrar si estamos interactuando CON EL CONTENIDO (texto, inputs, scrollbars)
            // Permitimos arrastrar solo si es el Header O si es el "borde" (el padding del contenedor principal)
            // Si el clic ocurre DENTRO del cuerpo de la nota, no arrastramos.
            if (target.closest('.floating-note-body')) return;

// Si pasa los filtros, iniciamos arrastre
            e.preventDefault(); // Evitar selección de texto indeseada
            document.body.classList.add('is-dragging-popup'); 
            
            isDragging = true;
            
            // FIX: Cerrar inmediatamente cualquier menú de Quill al iniciar el arrastre
            if (typeof window.closeAllQuillPickers === 'function') {
                window.closeAllQuillPickers();
            }

            el.classList.add('active-drag');
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            startX = clientX;
            startY = clientY;
            
            const rect = el.getBoundingClientRect();
            initialLeft = rect.left;
            initialTop = rect.top;
            
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('touchend', stopDrag);
        };

        const doDrag = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            // Calculamos nueva posición
            el.style.left = `${initialLeft + (clientX - startX)}px`;
            el.style.top = `${initialTop + (clientY - startY)}px`;
        };

        const stopDrag = () => {
            isDragging = false;
            document.body.classList.remove('is-dragging-popup');
            el.classList.remove('active-drag');
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', stopDrag);
            document.removeEventListener('touchmove', doDrag);
            document.removeEventListener('touchend', stopDrag);
        };

        // APLICAMOS EL LISTENER A TODO EL POPUP (el filtro arriba decide si se mueve o no)
        el.addEventListener('mousedown', startDrag);
        el.addEventListener('touchstart', startDrag, { passive: false });
    },
  
  

    makeResizable(el) {
        const handle = el.querySelector('.floating-resize-handle');
        let isResizing = false;
        let startX, startY, startW, startH;

        const startResize = (e) => {
            if(e.type === 'touchstart') e.preventDefault();
            e.stopPropagation(); 
            document.body.classList.add('is-dragging-popup');

            isResizing = true;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            startX = clientX; startY = clientY;
            const rect = el.getBoundingClientRect();
            startW = rect.width; startH = rect.height;
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);
            document.addEventListener('touchmove', doResize, { passive: false });
            document.addEventListener('touchend', stopResize);
        };
        const doResize = (e) => {
            if (!isResizing) return;
            if(e.type === 'touchmove') e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            const newW = startW + (clientX - startX);
            const newH = startH + (clientY - startY);
            if (newW > 300) el.style.width = `${newW}px`;
            if (newH > 200) el.style.height = `${newH}px`;
        };
        const stopResize = () => {
            isResizing = false;
            document.body.classList.remove('is-dragging-popup');
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopResize);
            document.removeEventListener('touchmove', doResize);
            document.removeEventListener('touchend', stopResize);
        };
        handle.addEventListener('mousedown', startResize);
        handle.addEventListener('touchstart', startResize, { passive: false });
    }
};
  
  
  
  
  
  
  
  
  </script>

</body>
</html>